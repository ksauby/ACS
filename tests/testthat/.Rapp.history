setwd('/Users/KSauby/Documents/Projects/ACSampling_project')
# load ProjectTemplate#
setwd('/Users/KSauby/Documents/Projects/ACSampling_project')#
library(ProjectTemplate)#
#
# when working on a Windows computer#
# setwd("C:/Users/KSauby/Dropbox/gradschool/Research/Projects/sampling")#
#
# load project#
load.project()
setwd('/Users/KSauby/Documents/Projects')
setwd("./ACS")#
devtools::test()
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calculatePopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("y_HT, Horvitz-Thompson Mean Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98)), #
				sampling = "SRSWOR", #
				criterion = 0#
			)*1000, 0#
		),#
		equals(38)#
	)#
	# Example from Thompson (1990), end of second full paragraph, p. 1055#
	mk <- c(1,0,2,2)#
	y_value <- c(1,2,10,1000)#
	sampling <- c("S","C","S","C")#
	dat <- data.frame(mk, y_value, sampling)#
	dat$mk %<>% as.numeric#
	dat$y_value %<>% as.numeric#
	dat_filter <- dat %>% filter(sampling=="S" | y_value > 4)#
	expect_that(#
		round(#
			y_HT(#
				N = 5, #
				m = dat_filter$mk, #
				n1 = 2, #
				y = dat_filter$y_value#
			), 2#
		),#
		equals(289.07)#
	)#
})#
#
test_that("pi_i, Network Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			pi_i(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1:2], 2#
		),#
		equals(c(0.19, 0.27))#
	)#
})#
#
test_that("pi_ij, Network Joint Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# answer in the book is 0.0511 but I get 0.0512; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			pi_ij(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1, 2], 4#
		),#
		equals(0.0512)#
	)#
})#
#
test_that("var_y_HT, Horvitz-Thompson Variance Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# Horvitz Thompson variance of the total, (using the variance of the mean, and then multiply by N^2)#
	# answer in the book is 552 but I get 553; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			var_y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98))#
			)*(1000^2), 0#
		),#
		equals(553)#
	)#
})#
#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	# I get 17.6854 if I round(pi_ij_values, 4) and round(y_hat, 2)#
	expect_that(#
		round(#
			R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(12.12)#
	)#
})#
test_that("var_R_hat, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	expect_that(#
		round(#
			var_R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(17.5)#
	)#
})#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	# Exercise #3, p. 85, Thompson (2002)#
	N 		<- 4#
	dat 	<- data.frame(y = c(2, 3, 0, 1), x = c(20, 25, 0, 15))#
	combin 	<- combn(4,2)#
	combin	<- split(combin, col(combin))#
	combos 	<- lapply(combin, function(x) dat[row(dat) %in% x, ])#
	combos %<>% lapply(., function(x) filter(x, !(is.na(y))))#
	expect_that(#
		lapply(#
			combos, #
			function(x) round(#
				R_hat(#
					x$y, #
					x$x, #
					N = 4, #
					n1 = 2, #
					m = c(1,1)#
				)*(20 + 25 + 15), 6#
			)#
		),#
		equals(#
			list(#
				`1` = 6.666667, #
				`2` = 6, #
				`3` = 5.142857, #
				`4` = 7.2, #
				`5` = 6, #
				`6` = 4#
			)#
		)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the Horvitz-Thompson Ratio Estimator#
#' @description R_hat is calculated by dividing the Horvitz-Thompson estimator, Tau_hat_z by Tau_hat_x. See p. 77, Thompson (2002). THERE CANNOT BE NAS IN X OR Y?#
#' @param y Attribute data about species of interest y (e.g., abundance, presence/absence).#
#' @param x Auxiliary data about object of interest y.#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param replace Whether sampling should be done with or without replacement. Defaults to \code{FALSE}.#
#' @examples#
#' # Example from Thompson (2002), p. 78-79#
#' N = 100#
#' n1 = 4#
#' y = c(60, 14, 1)#
#' x = c(1, 1, 1)#
#' m = c(5, 2, 1)#
#' R_hat(y, x, N, n1, m, replace="TRUE")#
#' var_R_hat(y, x, N, n1, m, replace="TRUE")#
#' @export#
#
R_hat <- function(y, x, N, n1, m, replace="FALSE") {#
	if (replace=="TRUE") {#
		alpha_stars <- pi_i_replace(N, n1, m)#
	} else {#
		alpha_stars <- pi_i(N, n1, m)#
	}#
	dat <- data.frame(alpha_stars = alpha_stars, y = y, x = x)#
	mu_x = sum(dat$x/dat$alpha_stars)#
	if (mu_x == 0) {#
		return(0)#
	} else {#
		sum(dat$y/dat$alpha_stars, na.rm=T) / mu_x#
	}#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the Horvitz-Thompson mean of an adaptive cluster sample.#
#' #
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size. #
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param n1 Initial sample size.#
#' @param y Attribute data about species of interest (e.g., abundance, presence/absence).#
#' @param sampling A vector (\code{character} format) describing whether units were included in the initial sample or subsequent ACS sample. Units selected in the initial sample should be given the value "Initial_Sample" in the \code{sampling} vector.#
#' @param criterion The threshold value of \code{y} that triggers adaptive cluster sampling.#
#' @description This calculate the Horvitz-Thompson mean of an adaptive cluster sample done by sampling without replacement.#
#'#
#'where $v$ is the number of distinct units in the sample and#
#'$J_k$ is an indicator variable, equalling 0 if the $k$ th unit in the sample does not satisfy the condition and was not selected in the initial sample; otherwise, $J_k = 1$.#
#' #
#' @return The Horvitz-Thompson mean.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @examples #
#' library(magrittr)#
#' library(plyr)#
#' library(dplyr)#
#' library(ggplot2)#
#'#
#' # EXAMPLE 1: Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # REPLACE WITH CREATEACS FUNCTION#
#'#
#' # INITIATE ACS#
#' # assign species information to units in the initial sample#
#' S = merge(#
#' 	Thompson1990Figure1Population,#
#' 	Thompson1990Figure1Sample, #
#' 	all.y=TRUE#
#' )#
#' #
# create list of neighboring ("cluster") plots#
#' Z = list()  					#
#' S$Sampling <- "Initial_Sample"#
#' # add the rest of the units for each network in the initial sample#
#' Z = rbind.fill(S, Thompson1990Figure1Population %>% #
#' 	filter(Thompson1990Figure1Population$NetworkID %in% S$NetworkID))#
#' Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
#' Networks = filter(Z, y_value > 0)#
#' # fill in edge units#
#' E = as.data.frame(cbind(#
#' 	x = rowSums(expand.grid(Networks$x, c(1,-1,0,0))),#
#' 	y = rowSums(expand.grid(Networks$y, c(0,0,1,-1)))#
#' )) %>% #
#' mutate(Sampling="Edge")#
#' # remove duplicate units#
#' Z %<>% rbind.fill(E) %>%#
#' mutate(temp_coords = paste(x, y, sep=""))#
#' Z =  Z[!duplicated(Z$temp_coords),]#
#' Z %<>% dplyr::select(-temp_coords)#
#' # fill in y_value#
#' Z[which(is.na(Z$y_value)), ]$y_value <- 0#
#' # fill in m#
#' Z[which(Z$y_value==0 & Z$Sampling=="Edge"), ]$m <- 0#
#' #
#' 	N = dim(Thompson1990Figure1Population)[1] #
#' 	n1 = dim(Thompson1990Figure1Sample)[1]#
#' 	m = Z$m#
#' 	y = Z$y_value#
#' 	sampling = Z$Sampling#
#' 	criterion=0#
#
#' # CALCULATE y_HT#
#' y_HT(#
#' 	N = N, #
#' 	n1 = n1,#
#' 	m = m, #
#' 	y = y, #
#' 	sampling = Z$Sampling,#
#' 	criterion=0#
#' ) #
#'#
#' # EXAMPLE 2: Table 1 from Thompson (1990)#
#' data(Thompson1990Table1data)#
#' (Thompson1990Table1 = Thompson1990Table1data %>%#
#' group_by(sampling_effort) %>%#
#' summarise(#
#' 	`y (added through SRSWOR)` = toString(y_value[which(sampling=="SRSWOR")]),#
#' 	`y (added through ACS)` = toString(y_value[which(sampling=="ACS")]),#
#' 	y_bar_1 = mean(y_value[which(sampling=="SRSWOR")]),#
#' 	y_HT = round(y_HT(N, n1, m, y_value, sampling, 5), 2),#
#' 	y_bar = round(mean(y_value),2)#
#' 	)#
#' )#
#' #
#' # EXAMPLE 3: #
#' # data(cactus_realizations)#
#' # realization = cactus_realizations %>% filter(n.networks==40)#
#
#' # EXAMPLE 4:#
#' # Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
#' # Horvitz-Thompson mean times the population size; should equal 38#
#' y_HT(#
#'     N 		= 1000, #
#'     n1 		= 100, #
#'     m 		= c(2,3,rep(1,98)), #
#'     y 		= c(3,6,rep(0, 98)),#
#'     sampling = "SRSWOR",#
#'     criterion =0#
#' )*1000 %>% round(0)#
#
#' @export#
#
y_HT <- function(y, N, n1, pi_i_values=NULL, m=NULL, sampling=NULL, criterion=NULL) {#
	if (!(is.null(sampling)) & !(is.null(criterion))) {#
		J = ifelse(y >= criterion | sampling=="SRSWOR", 1, 0)#
	} else {#
		J = 1#
	}#
	if (is.null(pi_i_values)) {#
		pi_i_values = pi_i(N, n1, m)#
	}#
	y_HT = sum(y*J/pi_i_values, na.rm=T)/N#
	return(y_HT)	#
}#
#' Calculate the Horvitz-Thompson mean of an adaptive cluster sample, NEW FORMULA.#
#' #
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size. #
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param n1 Initial sample size.#
#' @param y Attribute data about species of interest (e.g., abundance, presence/absence).#
#' @param sampling A vector (\code{character} format) describing whether units were included in the initial sample or subsequent ACS sample. Units selected in the initial sample should be given the value "Initial_Sample" in the \code{sampling} vector.#
#' @param criterion The threshold value of \code{y} that triggers adaptive cluster sampling.#
#' @param m_threshold NEEDS DESCRIPTION#
#' @description This calculate the Horvitz-Thompson mean of an adaptive cluster sample done by sampling without replacement.#
#'#
#'where $v$ is the number of distinct units in the sample and#
#'$J_k$ is an indicator variable, equalling 0 if the $k$ th unit in the sample does not satisfy the condition and was not selected in the initial sample; otherwise, $J_k = 1$.#
#' #
#' @return The Horvitz-Thompson mean.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @export#
#' @examples #
#' # EXAMPLE 4:#
#' # Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
#' # Horvitz-Thompson mean times the population size; should equal 38#
#' new_y_HT(#
#'     y 		= c(3,6,rep(0, 98)),#
#'     N 		= 1000, #
#'     n1 		= 100, #
#'     m 		= c(2,3,rep(1,98)), #
#'     sampling = "SRSWOR",#
#'     criterion =0,#
#'	   m_threshold=2#
#' )#
#
new_y_HT <- function(y, N, n1, m_threshold, pi_i_values=NULL, m=NULL, sampling=NULL, criterion=NULL) {#
	if (!(is.null(sampling)) & !(is.null(criterion))) {#
		J = ifelse(y >= criterion | sampling=="SRSWOR", 1, 0)#
	} else {#
		J = 1#
	}#
	Z = data.frame(y=y, m=m)#
	# with replacement inclusion probability for cluster units#
	# pi_i = 1 - ( 1 - ((m + a)/N) )^ n#
	# how to make this work for a network#
	A <- Z %>% filter(m <= m_threshold)#
	B <- Z %>% filter(m > m_threshold)#
	if (dim(A)[1] > 0) {#
		A$pi_i_values = pi_i(N, n1, A$m)	#
	}#
	if (dim(B)[1] > 0) {	#
		B$pi_i_values = pi_i(N, n1, m_threshold)#
	}#
	Z <- bind.rows(A, B) %>% as.data.frame#
	y_HT = sum(unlist(Z$y)*J/unlist(Z$pi_i_values), na.rm=T)/N#
	return(y_HT)	#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the variance of R hat#
#' #
#' @param y Attribute data about object of interest y (e.g., abundance, presence/absence).#
#' @param x Auxiliary data about object of interest y.#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param replace Whether sampling should be done with or without replacement. Defaults to \code{FALSE}.#
#' @examples#
#' # Example from Thompson (2002), p. 78-79#
#' N = 100#
#' n1 = 4#
#' y = c(60, 60, 14, 1)#
#' x = c(1, 1, 1, 1)#
#' m = c(5, 5, 2, 1)#
#' R_hat(y, x, N, n1, m, replace="TRUE")#
#' var_R_hat(y, x, N, n1, m)#
#' @export#
var_R_hat <- function(y, x, N, n1, m, replace="FALSE") {#
	if (replace=="TRUE") {#
		pi_i_values <- pi_i_replace(N, n1, m)		#
		pi_ij_values <- pi_ij_replace(N, n1, m)#
	} else {#
		pi_i_values <- pi_i(N, n1, m)#
		pi_ij_values <- pi_ij(N, n1, m)#
	}#
	R_hat_estimate	<- R_hat(y, x, N, n1, m)#
	y_hat 			<- y - R_hat_estimate*x#
	# get information on unique networks#
	# calculate for all pairs#
	V <- R_hat_cpp(y_hat, pi_i_values, pi_ij_values)#
	# replace diagonal (where i = j)#
	# diag(V) <- 0#
	(1/(N^2)) * (sum(#
		((y_hat)^2) * (1/(pi_i_values^2) - 1/pi_i_values), na.rm=T#
	) + sum(V, na.rm=T)/2)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the variance of the Horvitz-Thompson estimator of the mean#
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size#
#' @param n1 Initial sample size#
#' @param m Vector of $m$, each corresponding to a unique network.#
#' @param y Vector of $y$ total, each corresponding to a unique network.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @useDynLib ACSampling#
#' @importFrom Rcpp sourceCpp#
#' @export#
#' @examples #
#' library(ggplot2)#
#' library(magrittr)#
#' library(dplyr)#
#' # Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, #
#' 	size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # INITIATE ACS#
#' Z = createACS(population_data=Thompson1990Figure1Population, #
#' 	n1=dim(Thompson1990Figure1Sample)[1], #
#' 	initial_sample=Thompson1990Figure1Sample, y_variable="y_value")#
#' #
#' # CALCULATE var(y_HT)#
#' # create dataframe of network info#
#' Z_summary <- Z %>% group_by(NetworkID) %>%#
#' 	summarise(#
#' 		m = m[1],#
#' 		y_total = sum(y_value, rm.na=TRUE)#
#' 		) %>%#
#' 		filter(NetworkID > 0)#
#' #
#' var_y_HT(#
#' 	N = dim(Thompson1990Figure1Population)[1], #
#' 	n1 = dim(Thompson1990Figure1Sample)[1], #
#' 	m = Z_summary$m, #
#' 	y = Z_summary$y_total#
#' )#
var_y_HT <- function(N, n1, m, y, pi_i_values=NULL) {#
	if (is.null(pi_i_values)) {#
		pi_i_values 	<- pi_i(N, n1, m)#
	}#
	pi_ij_values 		<- pi_ij(N, n1, m) %>% as.matrix#
	# replace diagonal (where h = j)#
	diag(pi_ij_values) 	<- pi_i_values	#
	# dataframe to store sum(k=1 to kappa) sum(m=1 to kappa)#
	V = as.data.frame(matrix(nrow=length(m), ncol=length(m), NA))#
	# calculate for all pairs#
	V <- var_y_HT_cpp(m, pi_i_values, pi_ij_values, y)#
	sum(V, na.rm=T)/(N^2)#
}#
#' Calculate the variance of the Horvitz-Thompson estimator of the mean using the RACS correction#
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size#
#' @param n1 Initial sample size#
#' @param m Vector of $m$, each corresponding to a unique network.#
#' @param y Vector of $y$ total, each corresponding to a unique network.#
#' @param m_threshold threshold value above which to calculate pi_i and pi_j differently.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @useDynLib ACSampling#
#' @importFrom Rcpp sourceCpp#
#' @export#
#' @examples#
#' library(ggplot2)#
#' library(magrittr)#
#' library(dplyr)#
#' # Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, #
#' 	size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # INITIATE ACS#
#' Z = createACS(population_data=Thompson1990Figure1Population, #
#' 	n1=dim(Thompson1990Figure1Sample)[1], #
#' 	initial_sample=Thompson1990Figure1Sample, y_variable="y_value")#
#' #
#' # CALCULATE var(y_HT)#
#' # create dataframe of network info#
#' Z_summary <- Z %>% group_by(NetworkID) %>%#
#' 	summarise(#
#' 		m = m[1],#
#' 		y_total = sum(y_value, rm.na=TRUE)#
#' 		) %>%#
#' 		filter(NetworkID > 0)#
#' #
#' var_y_HT_RACS(#
#' 	N = dim(Thompson1990Figure1Population)[1], #
#' 	n1 = dim(Thompson1990Figure1Sample)[1], #
#' 	m = Z_summary$m, #
#' 	y = Z_summary$y_total,#
#' 	m_threshold=3#
#' )#
#
var_y_HT_RACS <- function(N, n1, m, y, m_threshold, pi_i_values=NULL) {#
	Z = data.frame(y=y, m=m) %>% arrange(m)#
	A <- Z %>% filter(m <= m_threshold)#
	B <- Z %>% filter(m > m_threshold)#
	if (dim(A)[1] > 0) {#
		A$pi_i_values = pi_i(N, n1, A$m)	#
	}#
	if (dim(B)[1] > 0) {	#
		B$pi_i_values = pi_i(N, n1, m_threshold)#
	}#
	Z <- rbind.fill(A, B) %>% as.data.frame#
	pi_i_values 		<- Z$pi_i_values#
	pi_ij_values 		<- pi_ij_RACS(N, n1, m, m_threshold) %>% as.matrix#
	# replace diagonal (where h = j)#
	diag(pi_ij_values) 	<- Z$pi_i_values	#
	# dataframe to store sum(k=1 to kappa) sum(m=1 to kappa)#
	V = as.data.frame(matrix(nrow=length(m), ncol=length(m), NA))#
	# calculate for all pairs#
	V <- var_y_HT_cpp(m, pi_i_values, pi_ij_values, y)#
	sum(V, na.rm=T)/(N^2)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("y_HT, Horvitz-Thompson Mean Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98)), #
				sampling = "SRSWOR", #
				criterion = 0#
			)*1000, 0#
		),#
		equals(38)#
	)#
	# Example from Thompson (1990), end of second full paragraph, p. 1055#
	mk <- c(1,0,2,2)#
	y_value <- c(1,2,10,1000)#
	sampling <- c("S","C","S","C")#
	dat <- data.frame(mk, y_value, sampling)#
	dat$mk %<>% as.numeric#
	dat$y_value %<>% as.numeric#
	dat_filter <- dat %>% filter(sampling=="S" | y_value > 4)#
	expect_that(#
		round(#
			y_HT(#
				N = 5, #
				m = dat_filter$mk, #
				n1 = 2, #
				y = dat_filter$y_value#
			), 2#
		),#
		equals(289.07)#
	)#
})#
#
test_that("pi_i, Network Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			pi_i(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1:2], 2#
		),#
		equals(c(0.19, 0.27))#
	)#
})#
#
test_that("pi_ij, Network Joint Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# answer in the book is 0.0511 but I get 0.0512; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			pi_ij(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1, 2], 4#
		),#
		equals(0.0512)#
	)#
})#
#
test_that("var_y_HT, Horvitz-Thompson Variance Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# Horvitz Thompson variance of the total, (using the variance of the mean, and then multiply by N^2)#
	# answer in the book is 552 but I get 553; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			var_y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98))#
			)*(1000^2), 0#
		),#
		equals(553)#
	)#
})#
#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	# I get 17.6854 if I round(pi_ij_values, 4) and round(y_hat, 2)#
	expect_that(#
		round(#
			R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(12.12)#
	)#
})#
test_that("var_R_hat, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	expect_that(#
		round(#
			var_R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(17.5)#
	)#
})#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	# Exercise #3, p. 85, Thompson (2002)#
	N 		<- 4#
	dat 	<- data.frame(y = c(2, 3, 0, 1), x = c(20, 25, 0, 15))#
	combin 	<- combn(4,2)#
	combin	<- split(combin, col(combin))#
	combos 	<- lapply(combin, function(x) dat[row(dat) %in% x, ])#
	combos %<>% lapply(., function(x) filter(x, !(is.na(y))))#
	expect_that(#
		lapply(#
			combos, #
			function(x) round(#
				R_hat(#
					x$y, #
					x$x, #
					N = 4, #
					n1 = 2, #
					m = c(1,1)#
				)*(20 + 25 + 15), 6#
			)#
		),#
		equals(#
			list(#
				`1` = 6.666667, #
				`2` = 6, #
				`3` = 5.142857, #
				`4` = 7.2, #
				`5` = 6, #
				`6` = 4#
			)#
		)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the inclusion probability of unit $i$ in a simple random sample without replacement. #
#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Vector of values giving the number of units satisfying the ACS criterion in network $i$.#
#
#' @return vector of inclusion probabilities#
#
#' @examples #
#' # example from section 4, p. 1055 (first column) in Thompson (1990)#
#' N = 5#
#' n1 = 2#
#' y = c(1,10,1000)#
#' m = c(1,2,2)#
#' pi_i(N, n1, m)#
#' # EXAMPLE 4:#
#' # Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
#' N=1000#
#' n1=100#
#' m=c(2,3,rep(1,98))#
#' head(pi_i(N, n1, m))#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson. 1990.#
#' @export#
#
pi_i <- function(N, n1, m) {#
  sapply(m, function(m) #
    1 - exp(#
		sum(log({N - m - n1 + 1} : {N - m})) - sum(log({N - n1 + 1} : N))#
		)#
  )#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the inclusion probability of unit $i$ in a simple random sample with replacement. #
#' #
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Vector of values giving the number of units satisfying the ACS criterion in netwalpha_star_iork $i$.#
#' @return vector of inclusion probabilities#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#
pi_i_replace <- function(N, n1, m) {#
  sapply(m, function(m) 1 - (1 - m/N)^n1)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate joint inclusion probability of unit $j$ and $h$#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Vector of values giving the number of units satisfying the ACS criterion in network $i$.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @examples #
#' # Thompson sampling book, ch. 24 exercises, p. 307, number 2#
#' library(magrittr)#
#' N=1000#
#' n1=100#
#' m=c(2,3,rep(1,98))#
#' pi_ij(N, n1, m) %>% .[1,2]#
#' @export#
#
pi_ij <- function(N, n1, m) {#
	N_n1 	<- choose(N, n1)#
	# vector of binom(N-mj, n1)#
	N_m_n1 	<- sapply(m, function(m) choose(N - m, n1)) #
	N_m_m_n1 = matrix(#
		nrow = length(m), #
		ncol = length(m), #
		NA#
	) # store binom(N-mj-mh, n1)#
	for (j in 1 : length(m)) {#
	  N_m_m_n1[j, ] = choose((N - m[j] - m), n1)#
	}	#
	pi_ij_cpp(m, N_n1, N_m_n1, N_m_m_n1)#
}#
#
#' Calculate joint inclusion probability of unit $j$ and $h$, using the RACS correction#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Vector of values giving the number of units satisfying the ACS criterion in network $i$.#
#' @param m_threshold threshold value above which to calculate pi_i and pi_j differently.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @examples #
#' # Thompson sampling book, ch. 24 exercises, p. 307, number 2#
#' library(magrittr)#
#' N=1000#
#' n1=100#
#' m=c(2,3,rep(1,98))#
#' pi_ij(N, n1, m) %>% .[1,2]#
#' @export#
#
pi_ij_RACS <- function(N, n1, m, m_threshold) {#
	N_n1 				<- choose(N, n1)#
	N_m_threshold_n1 	<- choose(N - m_threshold, n1)#
	N_2m_threshold_n1 	<- choose(N - 2*m_threshold, n1)#
	# vector of binom(N-mj, n1)#
	N_m_n1 	<- sapply(m, function(m) choose(N - m, n1)) #
	N_m_m_n1 = matrix(#
		nrow = length(m), #
		ncol = length(m), #
		NA#
	) # store binom(N-mj-mh, n1)#
	N_m_threshold_m_n1 = NA#
	for (j in 1 : length(m)) {#
	  N_m_m_n1[j, ] = choose((N - m[j] - m), n1)#
	}#
	for (j in 1 : length(m)) {#
	  N_m_threshold_m_n1[j] = choose((N - m_threshold - m[j]), n1)#
	}#
	pi_ij_RACS_cpp(#
		m, #
		N_n1, #
		N_m_threshold_n1, #
		N_2m_threshold_n1,#
		m_threshold,#
		N_m_n1,#
		N_m_threshold_m_n1,#
		N_m_m_n1#
	)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate joint inclusion probability of unit $j$ and $h$#
#' @param N Population size.#
#' @param n1 Initial sample size.#
#' @param m Vector of values giving the number of units satisfying the ACS criterion in network $i$.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @export#
#
pi_ij_replace <- function(N, n1, m) {#
	pi_ij = matrix(#
		nrow = length(m), #
		ncol = length(m), #
		NA#
	)#
	for (i in 1 : length(m)) {#
		for (j in 1 : length(m)) {#
			pi_ij[i, j] <- #
			1 - (#
				(1 - m[i]/N)^n1 + #
				(1 - m[j]/N)^n1 -#
				 (1 - (m[i] + m[j])/N)^n1#
				)#
		}#
	}#
	return(pi_ij)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("y_HT, Horvitz-Thompson Mean Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98)), #
				sampling = "SRSWOR", #
				criterion = 0#
			)*1000, 0#
		),#
		equals(38)#
	)#
	# Example from Thompson (1990), end of second full paragraph, p. 1055#
	mk <- c(1,0,2,2)#
	y_value <- c(1,2,10,1000)#
	sampling <- c("S","C","S","C")#
	dat <- data.frame(mk, y_value, sampling)#
	dat$mk %<>% as.numeric#
	dat$y_value %<>% as.numeric#
	dat_filter <- dat %>% filter(sampling=="S" | y_value > 4)#
	expect_that(#
		round(#
			y_HT(#
				N = 5, #
				m = dat_filter$mk, #
				n1 = 2, #
				y = dat_filter$y_value#
			), 2#
		),#
		equals(289.07)#
	)#
})#
#
test_that("pi_i, Network Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			pi_i(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1:2], 2#
		),#
		equals(c(0.19, 0.27))#
	)#
})#
#
test_that("pi_ij, Network Joint Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# answer in the book is 0.0511 but I get 0.0512; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			pi_ij(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1, 2], 4#
		),#
		equals(0.0512)#
	)#
})#
#
test_that("var_y_HT, Horvitz-Thompson Variance Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# Horvitz Thompson variance of the total, (using the variance of the mean, and then multiply by N^2)#
	# answer in the book is 552 but I get 553; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			var_y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98))#
			)*(1000^2), 0#
		),#
		equals(553)#
	)#
})#
#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	# I get 17.6854 if I round(pi_ij_values, 4) and round(y_hat, 2)#
	expect_that(#
		round(#
			R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(12.12)#
	)#
})#
test_that("var_R_hat, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	expect_that(#
		round(#
			var_R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(17.5)#
	)#
})#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	# Exercise #3, p. 85, Thompson (2002)#
	N 		<- 4#
	dat 	<- data.frame(y = c(2, 3, 0, 1), x = c(20, 25, 0, 15))#
	combin 	<- combn(4,2)#
	combin	<- split(combin, col(combin))#
	combos 	<- lapply(combin, function(x) dat[row(dat) %in% x, ])#
	combos %<>% lapply(., function(x) filter(x, !(is.na(y))))#
	expect_that(#
		lapply(#
			combos, #
			function(x) round(#
				R_hat(#
					x$y, #
					x$x, #
					N = 4, #
					n1 = 2, #
					m = c(1,1)#
				)*(20 + 25 + 15), 6#
			)#
		),#
		equals(#
			list(#
				`1` = 6.666667, #
				`2` = 6, #
				`3` = 5.142857, #
				`4` = 7.2, #
				`5` = 6, #
				`6` = 4#
			)#
		)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
test_that("y_HT, Horvitz-Thompson Mean Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98)), #
				sampling = "SRSWOR", #
				criterion = 0#
			)*1000, 0#
		),#
		equals(38)#
	)#
	# Example from Thompson (1990), end of second full paragraph, p. 1055#
	mk <- c(1,0,2,2)#
	y_value <- c(1,2,10,1000)#
	sampling <- c("S","C","S","C")#
	dat <- data.frame(mk, y_value, sampling)#
	dat$mk %<>% as.numeric#
	dat$y_value %<>% as.numeric#
	dat_filter <- dat %>% filter(sampling=="S" | y_value > 4)#
	expect_that(#
		round(#
			y_HT(#
				N = 5, #
				m = dat_filter$mk, #
				n1 = 2, #
				y = dat_filter$y_value#
			), 2#
		),#
		equals(289.07)#
	)#
})#
#
test_that("pi_i, Network Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			pi_i(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1:2], 2#
		),#
		equals(c(0.19, 0.27))#
	)#
})#
#
test_that("pi_ij, Network Joint Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# answer in the book is 0.0511 but I get 0.0512; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			pi_ij(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1, 2], 4#
		),#
		equals(0.0512)#
	)#
})#
#
test_that("var_y_HT, Horvitz-Thompson Variance Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# Horvitz Thompson variance of the total, (using the variance of the mean, and then multiply by N^2)#
	# answer in the book is 552 but I get 553; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			var_y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98))#
			)*(1000^2), 0#
		),#
		equals(553)#
	)#
})#
#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	# I get 17.6854 if I round(pi_ij_values, 4) and round(y_hat, 2)#
	expect_that(#
		round(#
			R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(12.12)#
	)#
})#
test_that("var_R_hat, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	expect_that(#
		round(#
			var_R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				replace="TRUE"#
			), 2#
		),#
		equals(17.5)#
	)#
})#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	# Exercise #3, p. 85, Thompson (2002)#
	N 		<- 4#
	dat 	<- data.frame(y = c(2, 3, 0, 1), x = c(20, 25, 0, 15))#
	combin 	<- combn(4,2)#
	combin	<- split(combin, col(combin))#
	combos 	<- lapply(combin, function(x) dat[row(dat) %in% x, ])#
	combos %<>% lapply(., function(x) filter(x, !(is.na(y))))#
	expect_that(#
		lapply(#
			combos, #
			function(x) round(#
				R_hat(#
					x$y, #
					x$x, #
					N = 4, #
					n1 = 2, #
					m = c(1,1)#
				)*(20 + 25 + 15), 6#
			)#
		),#
		equals(#
			list(#
				`1` = 6.666667, #
				`2` = 6, #
				`3` = 5.142857, #
				`4` = 7.2, #
				`5` = 6, #
				`6` = 4#
			)#
		)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the variance of the Horvitz-Thompson estimator of the mean#
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size#
#' @param n1 Initial sample size#
#' @param m Vector of $m$, each corresponding to a unique network.#
#' @param y Vector of $y$ total, each corresponding to a unique network.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @useDynLib ACSampling#
#' @importFrom Rcpp sourceCpp#
#' @export#
#' @examples #
#' library(ggplot2)#
#' library(magrittr)#
#' library(dplyr)#
#' # Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, #
#' 	size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # INITIATE ACS#
#' Z = createACS(population_data=Thompson1990Figure1Population, #
#' 	n1=dim(Thompson1990Figure1Sample)[1], #
#' 	initial_sample=Thompson1990Figure1Sample, y_variable="y_value")#
#' #
#' # CALCULATE var(y_HT)#
#' # create dataframe of network info#
#' Z_summary <- Z %>% group_by(NetworkID) %>%#
#' 	summarise(#
#' 		m = m[1],#
#' 		y_total = sum(y_value, rm.na=TRUE)#
#' 		) %>%#
#' 		filter(NetworkID > 0)#
#' #
#' var_y_HT(#
#' 	N = dim(Thompson1990Figure1Population)[1], #
#' 	n1 = dim(Thompson1990Figure1Sample)[1], #
#' 	m = Z_summary$m, #
#' 	y = Z_summary$y_total#
#' )#
var_y_HT <- function(N, n1, m, y, pi_i_values=NULL) {#
	if (is.null(pi_i_values)) {#
		pi_i_values 	<- pi_i(N, n1, m)#
	}#
	pi_ij_values 		<- pi_ij(N, n1, m) %>% as.matrix#
	# replace diagonal (where h = j)#
	diag(pi_ij_values) 	<- pi_i_values	#
	# dataframe to store sum(k=1 to kappa) sum(m=1 to kappa)#
	V = as.data.frame(matrix(nrow=length(m), ncol=length(m), NA))#
	# calculate for all pairs#
	V <- var_y_HT_cpp(m, pi_i_values, pi_ij_values, y)#
	sum(V, na.rm=T)/(N^2)#
}#
#' Calculate the variance of the Horvitz-Thompson estimator of the mean using the RACS correction#
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size#
#' @param n1 Initial sample size#
#' @param m Vector of $m$, each corresponding to a unique network.#
#' @param y Vector of $y$ total, each corresponding to a unique network.#
#' @param m_threshold threshold value above which to calculate pi_i and pi_j differently.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @useDynLib ACSampling#
#' @importFrom Rcpp sourceCpp#
#' @export#
#' @examples#
#' library(ggplot2)#
#' library(magrittr)#
#' library(dplyr)#
#' # Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, #
#' 	size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # INITIATE ACS#
#' Z = createACS(population_data=Thompson1990Figure1Population, #
#' 	n1=dim(Thompson1990Figure1Sample)[1], #
#' 	initial_sample=Thompson1990Figure1Sample, y_variable="y_value")#
#' #
#' # CALCULATE var(y_HT)#
#' # create dataframe of network info#
#' Z_summary <- Z %>% group_by(NetworkID) %>%#
#' 	summarise(#
#' 		m = m[1],#
#' 		y_total = sum(y_value, rm.na=TRUE)#
#' 		) %>%#
#' 		filter(NetworkID > 0)#
#' #
#' var_y_HT_RACS(#
#' 	N = dim(Thompson1990Figure1Population)[1], #
#' 	n1 = dim(Thompson1990Figure1Sample)[1], #
#' 	m = Z_summary$m, #
#' 	y = Z_summary$y_total,#
#' 	m_threshold=3#
#' )#
#
var_y_HT_RACS <- function(N, n1, m, y, m_threshold, pi_i_values=NULL) {#
	Z = data.frame(y=y, m=m) %>% arrange(m)#
	A <- Z %>% filter(m <= m_threshold)#
	B <- Z %>% filter(m > m_threshold)#
	if (dim(A)[1] > 0) {#
		A$pi_i_values = pi_i(N, n1, A$m)	#
	}#
	if (dim(B)[1] > 0) {	#
		B$pi_i_values = pi_i(N, n1, m_threshold)#
	}#
	Z <- rbind.fill(A, B) %>% as.data.frame#
	pi_i_values 		<- Z$pi_i_values#
	pi_ij_values 		<- pi_ij_RACS(N, n1, m, m_threshold) %>% as.matrix#
	# replace diagonal (where h = j)#
	diag(pi_ij_values) 	<- Z$pi_i_values	#
	# dataframe to store sum(k=1 to kappa) sum(m=1 to kappa)#
	V = as.data.frame(matrix(nrow=length(m), ncol=length(m), NA))#
	# calculate for all pairs#
	V <- var_y_HT_cpp(m, pi_i_values, pi_ij_values, y)#
	sum(V, na.rm=T)/(N^2)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Hakey variance estimator free of joint inclusion probability calculations for unequal probability sampling#
#' @param pi_i vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param n Initial sample size#
#' @description Option for the "var_pi" function.#
#' @references Hajek, J. (1964). Asymptotic theory of rejective sampling with varying probabilities from a finite population. The Annals of Mathematical Statistics.#
#' Berger, Y. G., & Tille, Y. (2009). Sampling with Unequal Probabilities. Handbook of Statistics, 1-17.#
#' @export#
Hajek <- function(pi_i, n) {#
	pi_i * (1 - pi_i) * n / (n - 1)#
}#
#' Variance estimator free of joint inclusion probability calculations for unequal probability sampling, Hajek#
#' @param n sample size#
#' @param y Vector of $y$ values.#
#' @param pi_i_values vector of first-order inclusion probabilities, calculated using \code{pi_i}.#
#' @references Berger, Y. G. (2005). Variance estimation with Chao's sampling scheme. Journal of Statistical Planning and Inference, 127(1-2), 253-277. http://doi.org/10.1016/j.jspi.2003.08.014#
#' @export#
#
var_Hajek <- function(n, y, pi_i_values) {#
	d_hat <- sum(1 - pi_i_values)#
	G_hat <- 1/d_hat * sum( (y/pi_i_values) * (1 - pi_i_values) )#
	n/(n - 1) * sum( (1 - pi_i_values) * (y/pi_i_values - G_hat)^2 )#
}#
#' Variance estimator free of joint inclusion probability calculations for unequal probability sampling#
#' @description This gives equation 9 on page 10 in Berger and Tille 2009.#
#' @param n sample size#
#' @param y Vector of $y$ values.#
#' @param pi_i_values vector of first-order inclusion probabilities, calculated using \code{pi_i}.#
#' @param estimator Options include "Hartley_Rao", "Hajek", "Rosen", "Berger", and "Deville".#
#' @references Hajek, J. (1964). Asymptotic theory of rejective sampling with varying probabilities from a finite population. The Annals of Mathematical Statistics.#
#' Berger, Y. G., & Tille, Y. (2009). Sampling with Unequal Probabilities. Handbook of Statistics, 1-17.#
#' @export#
#' @examples#
#' # Hajek Approximation#
#' library(dplyr)#
#' library(magrittr)#
#' Z = createACS(Thompson1990Figure1Population, seed=3, n1=30, "y_value", condition=0)#
#' Z_summary <- Z %>% #
#' 	dplyr::filter(Sampling!="Edge") %>%#
#' 	group_by(NetworkID) %>%#
#' 	filter(NetworkID > 0) %>%#
#' 	dplyr::summarise(#
#' 		m = m[1],#
#' 		y_total = sum(y_value, na.rm=TRUE)#
#' 	)#
#' var_y_HT(#
#' 	N = dim(Thompson1990Figure1Population)[1], #
#' 	n1 = dim(Thompson1990Figure1Sample)[1], #
#' 	m = Z_summary$m, #
#' 	y = Z_summary$y_total#
#' )#
#' pi_i_values <- pi_i(N=900,n1=30, m=Z_summary$m)#
#' Hajek(pi_i=pi_i_values, n=30)#
#' var_pi(#
#' 	n = 30, #
#' 	y = Z_summary$y_total, #
#' 	pi_i_values = pi_i_values,#
#' 	estimator = "Hajek"#
#' )#
var_pi <- function(n, y, pi_i_values, estimator) {#
	if (estimator == "Hajek") {#
		lambda_i_values <- alpha_i_values <- Hajek(pi_i_values, n)#
	}#
	B_hat <- sum(lambda_i_values * y/pi_i_values) / #
		sum(lambda_i_values)#
	e_i <- y/pi_i_values - B_hat#
	sum(alpha_i_values * e_i^2)#
	#if (estimator == "Hartley_Rao") {#
	#	alpha_i_values <- Hartley_Rao(pi_i_values, n)#
	#	lambda_i_values <- 1#
	#}#
	#if (estimator == "Rosen") {#
	#	lambda_i_values <- alpha_i_values <- Rosen(pi_i_values, n)#
	#}#
	#if (estimator == "Berger") {#
	#}#
	#if (estimator == "Deville") {#
	#	lambda_i_values <- alpha_i_values <- Deville(pi_i_values, n)#
	#}#
}#
#' Tille (2006) variance estimator free of joint inclusion probability calculations for unequal probability sampling#
#' @param n sample size#
#' @param y Vector of $y$ values.#
#' @param pi_i_values vector of first-order inclusion probabilities, calculated using \code{Hajek}.#
#' Tille, Y. (2006).#
#' @export#
var_Tille <- function(n, y, pi_i_values) {#
	b_k_values <- Hajek(pi_i_values, n=n)#
	# get the matrix of values by multiplying the vector by itself, #
	#	THEN set diagnonal to zero, #
	#	THEN set lower triangle to zero so that we are not counting pairwise combos of k and l twice#
	b_k_b_l_values <- b_k_values %x% b_k_values %>% #
		matrix(length(b_k_values), length(b_k_values))#
	diag(b_k_b_l_values) <- 0	#
	b_k_b_l_values[lower.tri(b_k_b_l_values)] <- 0#
	# do the same thing for y that we did for b#
	y_k_y_l_values <- y %x% y %>% matrix(length(y), length(y))#
	diag(y_k_y_l_values) <- 0#
	y_k_y_l_values[lower.tri(y_k_y_l_values)] <- 0#
	# do the same thing for pi that we did for b#
	pi_k_pi_l_values <- pi_i_values %x% pi_i_values %>%#
		matrix(length(pi_i_values), length(pi_i_values))#
	diag(pi_k_pi_l_values) <- 0#
	pi_k_pi_l_values[lower.tri(pi_k_pi_l_values)] <- 0#
	# Now, create the product ykyl bkbl / pikpil#
	#	THEN set diag to zero#
	#	THEN set lower triangle to zero#
	ykyl_bkbl__pikpil <- y_k_y_l_values * b_k_b_l_values / pi_k_pi_l_values#
	diag(ykyl_bkbl__pikpil) <- 0	#
	ykyl_bkbl__pikpil[lower.tri(ykyl_bkbl__pikpil)] <- 0#
	# var approx of y_hat HT on page 139 of Tille 2006#
	sum(#
		y^2/pi_i_values^2 *#
		(#
			b_k_values - b_k_values^2 / sum(b_k_values)#
		)#
	) -#
	1 / sum(b_k_values) * #
	sum(ykyl_bkbl__pikpil)#
#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate the Horvitz-Thompson mean of an adaptive cluster sample.#
#' #
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size. #
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param n1 Initial sample size.#
#' @param y Attribute data about species of interest (e.g., abundance, presence/absence).#
#' @param sampling A vector (\code{character} format) describing whether units were included in the initial sample or subsequent ACS sample. Units selected in the initial sample should be given the value "Initial_Sample" in the \code{sampling} vector.#
#' @param criterion The threshold value of \code{y} that triggers adaptive cluster sampling.#
#' @description This calculate the Horvitz-Thompson mean of an adaptive cluster sample done by sampling without replacement.#
#'#
#'where $v$ is the number of distinct units in the sample and#
#'$J_k$ is an indicator variable, equalling 0 if the $k$ th unit in the sample does not satisfy the condition and was not selected in the initial sample; otherwise, $J_k = 1$.#
#' #
#' @return The Horvitz-Thompson mean.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @examples #
#' library(magrittr)#
#' library(plyr)#
#' library(dplyr)#
#' library(ggplot2)#
#'#
#' # EXAMPLE 1: Sampling of population from Figure 1, Thompson (1990)#
#'#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # plot sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Figure1Population, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Thompson1990Figure1Sample, aes(x,y), shape=0, size=7)#
#' #
#' # REPLACE WITH CREATEACS FUNCTION#
#'#
#' # INITIATE ACS#
#' # assign species information to units in the initial sample#
#' S = merge(#
#' 	Thompson1990Figure1Population,#
#' 	Thompson1990Figure1Sample, #
#' 	all.y=TRUE#
#' )#
#' #
# create list of neighboring ("cluster") plots#
#' Z = list()  					#
#' S$Sampling <- "Initial_Sample"#
#' # add the rest of the units for each network in the initial sample#
#' Z = rbind.fill(S, Thompson1990Figure1Population %>% #
#' 	filter(Thompson1990Figure1Population$NetworkID %in% S$NetworkID))#
#' Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
#' Networks = filter(Z, y_value > 0)#
#' # fill in edge units#
#' E = as.data.frame(cbind(#
#' 	x = rowSums(expand.grid(Networks$x, c(1,-1,0,0))),#
#' 	y = rowSums(expand.grid(Networks$y, c(0,0,1,-1)))#
#' )) %>% #
#' mutate(Sampling="Edge")#
#' # remove duplicate units#
#' Z %<>% rbind.fill(E) %>%#
#' mutate(temp_coords = paste(x, y, sep=""))#
#' Z =  Z[!duplicated(Z$temp_coords),]#
#' Z %<>% dplyr::select(-temp_coords)#
#' # fill in y_value#
#' Z[which(is.na(Z$y_value)), ]$y_value <- 0#
#' # fill in m#
#' Z[which(Z$y_value==0 & Z$Sampling=="Edge"), ]$m <- 0#
#' #
#' 	N = dim(Thompson1990Figure1Population)[1] #
#' 	n1 = dim(Thompson1990Figure1Sample)[1]#
#' 	m = Z$m#
#' 	y = Z$y_value#
#' 	sampling = Z$Sampling#
#' 	criterion=0#
#
#' # CALCULATE y_HT#
#' y_HT(#
#' 	N = N, #
#' 	n1 = n1,#
#' 	m = m, #
#' 	y = y, #
#' 	sampling = Z$Sampling,#
#' 	criterion=0#
#' ) #
#'#
#' # EXAMPLE 2: Table 1 from Thompson (1990)#
#' data(Thompson1990Table1data)#
#' (Thompson1990Table1 = Thompson1990Table1data %>%#
#' group_by(sampling_effort) %>%#
#' summarise(#
#' 	`y (added through SRSWOR)` = toString(y_value[which(sampling=="SRSWOR")]),#
#' 	`y (added through ACS)` = toString(y_value[which(sampling=="ACS")]),#
#' 	y_bar_1 = mean(y_value[which(sampling=="SRSWOR")]),#
#' 	y_HT = round(y_HT(N, n1, m, y_value, sampling, 5), 2),#
#' 	y_bar = round(mean(y_value),2)#
#' 	)#
#' )#
#' #
#' # EXAMPLE 3: #
#' # data(cactus_realizations)#
#' # realization = cactus_realizations %>% filter(n.networks==40)#
#
#' # EXAMPLE 4:#
#' # Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
#' # Horvitz-Thompson mean times the population size; should equal 38#
#' y_HT(#
#'     N 		= 1000, #
#'     n1 		= 100, #
#'     m 		= c(2,3,rep(1,98)), #
#'     y 		= c(3,6,rep(0, 98)),#
#'     sampling = "SRSWOR",#
#'     criterion =0#
#' )*1000 %>% round(0)#
#
#' @export#
#
y_HT <- function(y, N, n1, pi_i_values=NULL, m=NULL, sampling=NULL, criterion=NULL) {#
	if (!(is.null(sampling)) & !(is.null(criterion))) {#
		J = ifelse(y >= criterion | sampling=="SRSWOR", 1, 0)#
	} else {#
		J = 1#
	}#
	if (is.null(pi_i_values)) {#
		pi_i_values = pi_i(N, n1, m)#
	}#
	y_HT = sum(y*J/pi_i_values, na.rm=T)/N#
	return(y_HT)	#
}#
#' Calculate the Horvitz-Thompson mean of an adaptive cluster sample, NEW FORMULA.#
#' #
#' @param pi_i_values vector of inclusion probabilities, if not calculated using this function. Default is \code{NULL}.#
#' @param N Population size. #
#' @param m Number of units satisfying the ACS criterion in network $i$.#
#' @param n1 Initial sample size.#
#' @param y Attribute data about species of interest (e.g., abundance, presence/absence).#
#' @param sampling A vector (\code{character} format) describing whether units were included in the initial sample or subsequent ACS sample. Units selected in the initial sample should be given the value "Initial_Sample" in the \code{sampling} vector.#
#' @param criterion The threshold value of \code{y} that triggers adaptive cluster sampling.#
#' @param m_threshold NEEDS DESCRIPTION#
#' @description This calculate the Horvitz-Thompson mean of an adaptive cluster sample done by sampling without replacement.#
#'#
#'where $v$ is the number of distinct units in the sample and#
#'$J_k$ is an indicator variable, equalling 0 if the $k$ th unit in the sample does not satisfy the condition and was not selected in the initial sample; otherwise, $J_k = 1$.#
#' #
#' @return The Horvitz-Thompson mean.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#'#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @export#
#' @examples #
#' # EXAMPLE 4:#
#' # Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
#' # Horvitz-Thompson mean times the population size; should equal 38#
#' new_y_HT(#
#'     y 		= c(3,6,rep(0, 98)),#
#'     N 		= 1000, #
#'     n1 		= 100, #
#'     m 		= c(2,3,rep(1,98)), #
#'     sampling = "SRSWOR",#
#'     criterion =0,#
#'	   m_threshold=2#
#' )#
#
new_y_HT <- function(y, N, n1, m_threshold, pi_i_values=NULL, m=NULL, sampling=NULL, criterion=NULL) {#
	if (!(is.null(sampling)) & !(is.null(criterion))) {#
		J = ifelse(y >= criterion | sampling=="SRSWOR", 1, 0)#
	} else {#
		J = 1#
	}#
	Z = data.frame(y=y, m=m)#
	# with replacement inclusion probability for cluster units#
	# pi_i = 1 - ( 1 - ((m + a)/N) )^ n#
	# how to make this work for a network#
	A <- Z %>% filter(m <= m_threshold)#
	B <- Z %>% filter(m > m_threshold)#
	if (dim(A)[1] > 0) {#
		A$pi_i_values = pi_i(N, n1, A$m)	#
	}#
	if (dim(B)[1] > 0) {	#
		B$pi_i_values = pi_i(N, n1, m_threshold)#
	}#
	Z <- bind.rows(A, B) %>% as.data.frame#
	y_HT = sum(unlist(Z$y)*J/unlist(Z$pi_i_values), na.rm=T)/N#
	return(y_HT)	#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
# Generated by using Rcpp::compileAttributes() -> do not edit by hand#
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393#
#
pi_ij_cpp <- function(m, N_n1, N_m_n1, N_m_m_n1) {#
    .Call('_ACSampling_pi_ij_cpp', PACKAGE = 'ACSampling', m, N_n1, N_m_n1, N_m_m_n1)#
}#
#
pi_ij_RACS_cpp <- function(m, N_n1, N_m_threshold_n1, N_2m_threshold_n1, m_threshold, N_m_n1, N_m_threshold_m_n1, N_m_m_n1) {#
    .Call('_ACSampling_pi_ij_RACS_cpp', PACKAGE = 'ACSampling', m, N_n1, N_m_threshold_n1, N_2m_threshold_n1, m_threshold, N_m_n1, N_m_threshold_m_n1, N_m_m_n1)#
}#
#
var_y_HT_cpp <- function(m, pi_i_values, pi_ij_values, y) {#
    .Call('_ACSampling_var_y_HT_cpp', PACKAGE = 'ACSampling', m, pi_i_values, pi_ij_values, y)#
}#
#
R_hat_cpp <- function(y_hat, pi_i_values, pi_ij_values) {#
    .Call('_ACSampling_R_hat_cpp', PACKAGE = 'ACSampling', y_hat, pi_i_values, pi_ij_values)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
test_that("y_HT, Horvitz-Thompson Mean Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98)), #
				sampling = "SRSWOR", #
				criterion = 0#
			)*1000, 0#
		),#
		equals(38)#
	)#
	# Example from Thompson (1990), end of second full paragraph, p. 1055#
	mk <- c(1,0,2,2)#
	y_value <- c(1,2,10,1000)#
	sampling <- c("S","C","S","C")#
	dat <- data.frame(mk, y_value, sampling)#
	dat$mk %<>% as.numeric#
	dat$y_value %<>% as.numeric#
	dat_filter <- dat %>% filter(sampling=="S" | y_value > 4)#
	expect_that(#
		round(#
			y_HT(#
				N = 5, #
				m = dat_filter$mk, #
				n1 = 2, #
				y = dat_filter$y_value#
			), 2#
		),#
		equals(289.07)#
	)#
})#
#
test_that("pi_i, Network Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	expect_that(#
		round(#
			pi_i(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1:2], 2#
		),#
		equals(c(0.19, 0.27))#
	)#
})#
#
test_that("pi_ij, Network Joint Inclusion Probability", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# answer in the book is 0.0511 but I get 0.0512; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			pi_ij(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98))#
			)[1, 2], 4#
		),#
		equals(0.0512)#
	)#
})#
#
test_that("var_y_HT, Horvitz-Thompson Variance Estimator", {#
	# Ch. 24, Exercise #2, p. 307, from Thompson (2002)#
	# Horvitz Thompson variance of the total, (using the variance of the mean, and then multiply by N^2)#
	# answer in the book is 552 but I get 553; I'm going to assume that this is due to a rounding error in the book's calculation#
	expect_that(#
		round(#
			var_y_HT(#
				N = 1000, #
				n1 = 100, #
				m = c(2,3,rep(1,98)), #
				y = c(3,6,rep(0, 98))#
			)*(1000^2), 0#
		),#
		equals(553)#
	)#
})#
#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	# I get 17.6854 if I round(pi_ij_values, 4) and round(y_hat, 2)#
	expect_that(#
		round(#
			R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				with_replacement="TRUE"#
			), 2#
		),#
		equals(12.12)#
	)#
})#
test_that("var_R_hat, with replacement", {#
	# Thompson (2002), Example 2, p. 78-79#
	expect_that(#
		round(#
			var_R_hat(#
				y = c(60, 14, 1), #
				x = c(1, 1, 1), #
				N = 100, #
				n1 = 4, #
				m = c(5, 2, 1), #
				replace="TRUE"#
			), 2#
		),#
		equals(17.5)#
	)#
})#
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	# Exercise #3, p. 85, Thompson (2002)#
	N 		<- 4#
	dat 	<- data.frame(y = c(2, 3, 0, 1), x = c(20, 25, 0, 15))#
	combin 	<- combn(4,2)#
	combin	<- split(combin, col(combin))#
	combos 	<- lapply(combin, function(x) dat[row(dat) %in% x, ])#
	combos %<>% lapply(., function(x) filter(x, !(is.na(y))))#
	expect_that(#
		lapply(#
			combos, #
			function(x) round(#
				R_hat(#
					x$y, #
					x$x, #
					N = 4, #
					n1 = 2, #
					m = c(1,1)#
				)*(20 + 25 + 15), 6#
			)#
		),#
		equals(#
			list(#
				`1` = 6.666667, #
				`2` = 6, #
				`3` = 5.142857, #
				`4` = 7.2, #
				`5` = 6, #
				`6` = 4#
			)#
		)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("R_hat, Horvitz-Thompson Ratio Estimator, without replacement", {#
	N=100#
	n1=13#
	m=c(5,5,5,5,5,3,3,3,1,1,1,1,1)#
	m_threshold=4#
	pi_ij_RACS_mthresh_6 	<- pi_ij_RACS(N,n1,m,m_threshold=6)#
	pi_ij_RACS_no_mthresh 	<- pi_ij(N,n1,m)#
	pi_ij_RACS_mthresh_4 	<- pi_ij_RACS(N,n1,m,m_threshold)#
#
	# ARE PI_IJ FORMULAS EQUIVALENT WHEN ALL M ARE BELOW M_THRESHOLD?#
	expect_that(#
		pi_ij_RACS_mthresh_6,#
		 equals(pi_ij_RACS_no_mthresh)	#
	)#
	# MANUALLY CALCULATE AND CHECK VALUES IN MATRIX#
	# 3 is not over m_threshold#
	# 3 is not over m_threshold#
	expect_that(#
		(vec = as.vector(pi_ij_RACS_mthresh_4[6:8,6:8])),#
		 equals(#
			rep(#
				1 - (#
					choose(N-3,n1) +#
					choose(N-3,n1) - #
					choose(N-3-3,n1)#
				) / choose(N,n1),#
				length(vec)#
			)#
		)	#
	)#
	# 5 is over threshold#
	# 3 is not#
	expect_that(#
		(vec = c(#
			pi_ij_RACS_mthresh_4[1:5,6:8],#
			pi_ij_RACS_mthresh_4[6:8,1:5]#
		)),#
		 equals(#
			rep(#
				1 - (#
					choose(N-m_threshold,n1) +#
					choose(N-3,n1) - #
					choose(N-m_threshold-3,n1)#
				) / choose(N,n1),#
				length(vec)#
			)#
		)	#
	)#
	# 5 is over threshold#
	# 1 is not#
	expect_that(#
		(vec = c(#
			pi_ij_RACS_mthresh_4[1:5,9:13],#
			pi_ij_RACS_mthresh_4[9:13,1:5]#
		)),#
		 equals(#
			rep(#
				1 - (#
					choose(N-m_threshold,n1) +#
					choose(N-1,n1) - #
					choose(N-m_threshold-1,n1)#
				) / choose(N,n1),#
				length(vec)#
			)#
		)	#
	)#
	# 3 is not over the threshold#
	# 1 is not over the threshold#
	expect_that(#
		(vec = c(#
			pi_ij_RACS_mthresh_4[6:8,9:13],#
			pi_ij_RACS_mthresh_4[9:13,6:8]#
		)),#
		 equals(#
			rep(#
				1 - (#
					choose(N-3,n1) +#
					choose(N-1,n1) - #
					choose(N-3-1,n1)#
				) / choose(N,n1),#
				length(vec)#
			)#
		)	#
	)#
	# 1 is not over the threshold#
	# 1 is not over the threshold	#
	expect_that(#
		(vec = as.vector(pi_ij_RACS_mthresh_4[9:13,9:13])),#
		 equals(#
			rep(#
				1 - (#
					choose(N-1,n1) +#
					choose(N-1,n1) - #
					choose(N-1-1,n1)#
				) / choose(N,n1),#
				length(vec)#
			)#
		)	#
	)	#
}#
)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
# createSRS#
test_that("createSRS, Does the function work when setting the seed for random sampling?", {#
	data(Thompson1990Figure1Population)#
	Z <- createSRS(Thompson1990Figure1Population, 10, seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value==2), ])[1],#
		1#
	)#
})#
test_that("createSRS, Does the function work without setting the seed for random sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for without replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWOR"), ])[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for with replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10, replace=T)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWR"), ])[1],#
		10#
	)#
})#
# createACS#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=2)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Are y-values of edge units equal to 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createACS, Are m-values of edge units 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createACS, Are there duplicates units in the sample?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})#
# createRACS#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createRACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", seed=5)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		4#
	)#
})#
test_that("createRACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		9#
	)#
})#
test_that("createRACS, Are y-values of edge units equal to 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createRACS, Are m-values of edge units 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createRACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
#
test_that("createRACS, Are there duplicates units in the sample?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create an Adaptive Cluster Sample.#
#'#
#' @param popdata The population to be sampled.#
#' @param seed A vector of numbers to feed to \code{set.seed()} so that the sampling is reproducible. Defaults to NA so that it is not necessary to specific a random number seed.#
#' @param n1 The initial sample size (sampled according to simple random sampling without replacement).#
#' @param yvar The variable of interest that is used to determine the condition under which adaptive cluster sampling takes place.#
#' @param condition Threshold value of the y variable that initiates ACS. Defaults to 0 (i.e., anything greater than 0 initiates adaptive cluster sampling).#
#' @param initsample Allows the user to specify a list of x and y coordinates of the initial sample. Defaults to "NA" so that the initial sample is selected according to simple random sampling without replacement.#
#
#' @return A restricted adaptive cluster sample.#
#
#' @examples#
#' library(ggplot2)#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # Initiate ACS#
#' Z = createACS(#
#'	popdata=Thompson1990Fig1Pop, #
#'	seed=9, #
#'	n1=10, #
#'	yvar="y_value", #
#'	condition=0#
#')#
#' #
#' # plot ACS sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Fig1Pop, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Z, aes(x,y), shape=0, size=7)#
#' # Initiate ACS, different seed#
#' Z = createACS(popdata=Thompson1990Fig1Pop, seed=26, n1=10, yvar="y_value", condition=0)#
#' #
#' # plot ACS sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Fig1Pop, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Z, aes(x,y), shape=0, size=7)#
#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} A Sampling Strategy Designed to Maximize the Efficiency of Data Collection of Food Web Relationships.#
#
#' @export#
#' @importFrom stringr str_pad#
#' @importFrom dplyr filter rowwise#
#' @importFrom ggplot2 ggplot#
#
createACS <- function(popdata, n1, yvar, condition=0, seed=NA, initsample=NA) {#
	YVAR <- sym(yvar)#
	. <- Sampling <- y_val <- NULL#
	if (is.data.frame(initsample)) {#
		S <- merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
	} else {#
		if (!is.na(seed)) {set.seed(seed)}#
		S <- createSRS(popdata=popdata, n1=n1)#
	}#
	# add the rest of the units for each network in the initial sample#
	Z = popdata %>%#
		dplyr::filter(.data$NetworkID %in% S$NetworkID) %>%#
		merge(S, all.x=T)#
	Networks = Z %>% filter(!!YVAR > condition)#
	# if there are units that satisfy the condition, fill in edge units#
	if (dim(Networks)[1] > 0) {#
		#Z %<>% rename(y_val = yvar)#
		# names(Z)[names(Z) == yvar] <- 'y_val'#
		#Z %<>%#
		#	as.data.table %>%#
		#	setnames(yvar, "y_val")#
		if (dim(Z[which(is.na(Z$Sampling)), ])[1] > 0) {#
			Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
		}#
		# fill in edge units#
		E = data.frame(#
			x = as.numeric(rowSums(expand.grid(Networks$x, c(1,-1,0,0)))),#
		  	y = rowSums(expand.grid(Networks$y, c(0,0,1,-1))),#
			Sampling = "Edge"#
		) %>%#
		rowwise() %>%#
		mutate(xy = paste(#
			str_pad(#
				.data$x,#
				nchar(max(popdata$x)),#
				"0",#
				side="left"#
			),#
			str_pad(#
				.data$y,#
				nchar(max(popdata$y)),#
				"0",#
				side="left"#
			)#
		)) %>%#
		ungroup()#
		Z %<>% #
			mutate(xy = paste(#
				str_pad(#
					.data$x,#
					nchar(max(popdata$x)),#
					"0",#
					side="left"#
				),#
				str_pad(#
					.data$y,#
					nchar(max(popdata$y)),#
					"0",#
					side="left"#
				)#
			)) %>%#
			ungroup()#
		E$Sampling %<>% as.character()#
		E %<>% filter(!(.data$xy %in% Z$xy))#
		ZZ <- Z %>% #
			bind_rows(E) %>%#
			group_by(x,y) %>%#
			filter(row_number()==1)#
		# remove plots outside of population extent#
		ZZ %<>% subset(#
			x %in% popdata$x &#
			y %in% popdata$y#
		)#
		# fill in values for Edge units#
		if (dim(#
			ZZ[which(#
				is.na(#
					eval(parse(text=paste(#
						"ZZ$", #
						yvar, #
						sep=""#
					)))#
				)#
			), ])[1] > 0) {#
			ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := replace(#
					y_val,#
					Sampling=="Edge",#
					0#
				),#
				m = replace(#
					m,#
					Sampling=="Edge",#
					0#
				)#
			)#
		}	#
		ZZ %<>%#
			arrange()#
		return(ZZ)#
	} else {#
		# if there are NO units that satisfy the condition, stop here and return the SRSWOR sample#
		return(Z)#
	}#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create a Restricted Adaptive Cluster Sample, for any step size#
#' #
#' @param population_data grid of population to be sampled.#
#' @param seed vector of numbers to feed to \code{set.seed()} so that the sampling is reproducible.#
#' @param n1 initial sample size (sampled according to simple random sampling without replacement).#
#' @param y_variable Variable of interest, used to determine condition under which adaptive cluster sampling takes place. Must be numeric. ACSampling is triggered when the y_variable is greater than the condition.#
#' @param condition Threshold value of the y variable that initiates Restricted ACS. Defaults to \code{0}. Must be numeric.#
#' @param f_max WHAT IS IT#
#' @param initial_sample List of x and y coordinates of the initial sample. Defaults to "NA" so that the initial sample is selected according to simple random sampling without replacement.#
#' @return A restricted adaptive cluster sample.#
#' @examples#
#' library(ggplot2)#
#' population_data = lambdap_5_tau_1#
#' seed=3#
#' n1=5#
#' y_variable = "y_value"#
#' f_max = 3#
#' Z = createRACS(#
#' 	popdata=lambdap_5_tau_1, #
#' 	n1=n1, #
#' 	yvar=yvar, #
#' 	seed=seed, #
#' 	f_max=f_max#
#' )#
#
#' ggplot() +#
#' geom_point(data=Z, aes(x,y, size=factor(y_variable),#
#' 		shape=factor(y_variable))) +#
#' scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' geom_point(data=Z, aes(x,y), shape = 0, size=7) +#
#' ggtitle("f_max = 1")#
#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} A Sampling Strategy Designed to Maximize the Efficiency of Data Collection of Food Web Relationships.#
#
#' @export#
#' @importFrom dplyr everything#
#
createRACS <- function(popdata, n1, yvar, condition=0, seed=NA, initsample=NULL, f_max=2) {#
	y_value <- x <- y <- Sampling <- NetworkID <- m <- NULL#
	# get primary sample#
	if (is.data.frame(initsample)) {#
		S = merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
		S$step <- 0#
		} else {#
			if (!is.na(seed)) {set.seed(seed)}#
				S <- createSRS(popdata, n1)#
				S$step <- 0#
	}#
	# filter out primary samples that satisfy the condition#
	Networks <- S %>% #
		filter(!! sym(yvar) > condition)#
	# if there are units that satisfy the condition, fill in cluster/edge units#
	if (dim(Networks)[1] > 0) {#
		#names(S)[names(S) == yvar] <- 'y_value'#
		#names(popdata)[names(popdata) == yvar] <- 'y_value'#
		# Lists to save data#
		Y = list()#
		Z = list()#
		# step 1: get all neighbors of primary samples matching condition#
	    for (i in 1:dim(Networks)[1]) {#
			L = Networks[i, ]#
    	    Y[[i]] <- list()#
			# STEP 1#
			Y[[i]][[1]] <- data.frame()#
    	    # northern neighbor of SRSWOR plot#
    	    Y[[i]][[1]][1, "x"] = L$x#
    	    Y[[i]][[1]][1, "y"] = L$y + 1#
	      	# southern neighbor of SRSWOR plot#
	      	Y[[i]][[1]][2, "x"] = L$x#
	      	Y[[i]][[1]][2, "y"] = L$y - 1#
	      	# eastern neighbor of SRSWOR plot#
	      	Y[[i]][[1]][3, "x"] = L$x + 1#
	      	Y[[i]][[1]][3, "y"] = L$y#
	      	# western neighbor of SRSWOR plot#
	      	Y[[i]][[1]][4, "x"] = L$x - 1#
	      	Y[[i]][[1]][4, "y"] = L$y#
			Y[[i]] <- do.call(rbind.fill, Y[[i]])#
		}#
		Z[[1]] <- do.call(rbind.fill, Y)#
		# merge neighbors and primary samples matching condition#
		Z[[1]]$step <- 1#
		Z[[1]] -> B#
		# steps 2 to f_max#
		if (f_max > 1) {#
			# get all neighbors of c(primary samples matching condition, neighbors) matching condition#
			for (j in 2:f_max) {#
				last_step = j-1#
				A <- B %>% filter(.data$step == last_step)#
				Z[[j]] <- list()#
				if (dim(A)[1] > 0) {#
					for (k in 1:dim(A)[1]) {#
						Z[[j]][[k]] <- data.frame()#
			    	    kx=A$x[k]#
			    	    ky=A$y[k]#
						# if plot has cacti, survey its neighbors#
						if (dim(popdata %>% #
							filter(#
			  					!! sym(yvar) > condition, #
			  			  		x==kx,#
			  			  		y==ky#
						))[1] > 0#
						) {#
						    # neighbor to north#
						    Z[[j]][[k]][1, "x"] = kx#
						   	Z[[j]][[k]][1, "y"] = ky - 1#
						    # neighbor to south#
						    Z[[j]][[k]][2, "x"] = kx#
						   	Z[[j]][[k]][2, "y"] = ky + 1#
						    # neighbor to east#
						    Z[[j]][[k]][3, "x"] = kx + 1#
						    Z[[j]][[k]][3, "y"] = ky#
						    # neighbor to west#
						    Z[[j]][[k]][4, "x"] = kx - 1#
						    Z[[j]][[k]][4, "y"] = ky#
						}#
						if (dim(Z[[j]][[k]])[1] > 0) {#
							Z[[j]][[k]]$step <- j#
						}#
					}#
					B <- do.call(rbind.fill, Z[[j]]) %>% #
						filter(!(is.na(x))) %>%#
						rbind.fill(B)#
					Z[[j]] <- do.call(rbind.fill, Z[[j]])#
				}#
			}#
			sample <- do.call(rbind.data.frame, Z)#
			} else {#
				sample <- do.call(rbind.data.frame, Z)#
		}#
	   	sample %<>%#
			merge(popdata, by=c("x", "y")) %>%#
	    	filter(!is.na(x) & !is.na(y)) %>% # remove NAs#
	    	rbind.fill(S) %>% # merge with SRSWOR plots#
			arrange(.data$step)#
	    # remove duplicates#
		no_duplicates <- sample[!duplicated(sample[, c("x", "y")]), ]#
		# give plots satisfying condition NetworkIDs#
		X = no_duplicates %>% #
			filter(!! sym(yvar) > condition) %>%#
		  	assignNetworkMembership#
		# give primary sample plots not satisfying condition NetworkIDs#
		Y = no_duplicates %>% filter(#
			!! sym(yvar) <= condition, #
			Sampling=="SRSWOR" | #
			Sampling=="SRSWR" | #
			Sampling=="Primary Sample"#
		)#
        Y$NetworkID <- seq(#
			from = (max(X$NetworkID) + 1), #
			to = (max(X$NetworkID) + dim(Y)[1]), #
			by = 1#
		)#
		# get list of cluster/edge plots not satifying condition#
		Z = no_duplicates %>% filter(!! sym(yvar) <= condition, is.na(Sampling))#
		# if there are plots not satisfying the condition, make NetworkIDs and m values of Cluster plots not satifying condition "NA"#
		if (dim(Z)[1] > 0) {#
			Z$NetworkID <- NA#
			Z$Sampling <- "Edge"#
			Z$m <- 0			#
			# merge back together		#
			Z = rbind.fill(X,Y,Z)	#
			} else {#
				# merge back together		#
				Z = rbind.fill(X,Y)			#
		}#
		if (dim(Z[which(is.na(Z$Sampling)), ])[1] > 0) {#
			Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
		}#
		# rename filtering variable#
		Z %<>% select(x, y, NetworkID, m, !! sym(yvar), Sampling, .data$step)#
		#names(Z)[names(Z) == 'y_value'] <- yvar#
		# add species attribute data#
		Z %<>% #
			merge(popdata %>% select(-NetworkID, -m)) %>%#
			select(x, y, NetworkID, m, y_value, Sampling, everything())#
		# warning	#
		if (dim(Z[duplicated(Z[, c("x", "y")]), ])[1] > 0) {#
			warning("Duplicates remaining in RACS sample")#
			stop()#
		}	#
  		return(Z)#
		} else {#
			# add species attribute data to sample#
			S %<>% merge(popdata)#
			return(S)#
	}#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create a Simple Random Sample Without Replacement.#
#' #
#' @param popdata grid of population to be sampled.#
#' @param seed vector of numbers to feed to \code{set.seed()} so that the sampling is reproducible. Defaults to NA so that it is not necessary to specific a random number seed.#
#' @param n1 initial sample size (sampled according to simple random sampling without replacement).#
#' @param replace Should sampling be done with replacement? Defaults to FALSE.#
#' @return A restricted adaptive cluster sample.#
#' @examples#
#' # example#
#' # create the population#
#' # create the patch#
#' # then sample#
#' #
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' Z = createSRS(Thompson1990Figure1Population, seed=2, n1=10)#
#' @export#
#
createSRS <- function(popdata, n1, seed=NA, replace=F) {#
	if (!is.na(seed)) {set.seed(seed)}#
	sample <- popdata[sample(#
		x 		= 1:dim(popdata)[1], #
		size 	= n1, #
		replace = replace#
	), ]#
	if (replace==F) {#
		sample$Sampling <- "SRSWOR"#
	} else {#
		sample$Sampling <- "SRSWR"#
	}#
	return(sample)		#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
# createSRS#
test_that("createSRS, Does the function work when setting the seed for random sampling?", {#
	data(Thompson1990Figure1Population)#
	Z <- createSRS(Thompson1990Figure1Population, 10, seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value==2), ])[1],#
		1#
	)#
})#
test_that("createSRS, Does the function work without setting the seed for random sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for without replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWOR"), ])[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for with replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10, replace=T)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWR"), ])[1],#
		10#
	)#
})#
# createACS#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=2)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Are y-values of edge units equal to 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createACS, Are m-values of edge units 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createACS, Are there duplicates units in the sample?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})#
# createRACS#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createRACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", seed=5)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		4#
	)#
})#
test_that("createRACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		9#
	)#
})#
test_that("createRACS, Are y-values of edge units equal to 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createRACS, Are m-values of edge units 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createRACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
#
test_that("createRACS, Are there duplicates units in the sample?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Assign network membership to adaptive cluster sample units.#
#
#' @param popdata Dataset to be used, containing information about units containing the species of interest, including x and y coordinates, with column names "x" and "y," respectively.#
#' @param plot.size The length and width of plots, in coordinate units. Defaults to 1.#
#
#' @description This function assigns network membership to units in an adaptive cluster sample; if units are neighbors, they are assigned to the same network ID. #
#
#' @return Returns popdata with a new column for Network ID as well as a column for m, the number of units in the network.#
#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#
#' @examples#
#' data(Thompson1990Figure1Population)#
#' #
#' # plot species abundance#
#' library(magrittr)#
#' library(ggplot2)#
#' library(dplyr)#
#' ggplot(data=Thompson1990Figure1Population %>% #
#' 	filter(y_value > 0), aes(x,y, size=factor(y_value))) + geom_point()#
#' #
#' # assign network membership of units containing the species of interest#
#' P_networks <- assignNetworkMembership(Thompson1990Figure1Population %>%#
#' 	 filter(y_value > 0))#
#' #
#' # plot networks#
#' ggplot(#
#' 	data=P_networks, #
#' 	aes(x,y, size=factor(y_value), shape=factor(NetworkID))#
#' ) + geom_point()#
#' # coordinates should be given as x and y#
#
#' @export#
#' @importFrom intergraph asIgraph#
#' @importFrom magrittr %>%#
#' @importFrom magrittr %<>%#
#' @importFrom dplyr group_by#
#' @importFrom dplyr mutate#
#' @importFrom stats dist#
#' @importFrom dplyr summarise_each#
#' @importFrom dplyr filter#
#' @importFrom magrittr %$%#
#' @importFrom dplyr arrange#
#' @importFrom dplyr select#
#' @importFrom network network#
#' @importFrom igraph clusters#
#
assignNetworkMembership <- function(popdata, plot.size=1) {#
	NetworkID <- x <- NULL#
	D <- as.matrix(dist(cbind(popdata$x, popdata$y), method="euclidian"))#
	D = ifelse(D > plot.size, 0, D)#
	D %<>% as.data.frame#
	G <- network(D, directed=FALSE) %>% asIgraph()#
	popdata$NetworkID <- clusters(G)$membership#
	popdata %<>%#
		group_by(NetworkID) %>%#
		mutate(m = length(x)) %>%#
		as.data.frame#
	return(popdata)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
# createSRS#
test_that("createSRS, Does the function work when setting the seed for random sampling?", {#
	data(Thompson1990Figure1Population)#
	Z <- createSRS(Thompson1990Figure1Population, 10, seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value==2), ])[1],#
		1#
	)#
})#
test_that("createSRS, Does the function work without setting the seed for random sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for without replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWOR"), ])[1],#
		10#
	)#
})#
test_that("createSRS, Does the function work for with replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10, replace=T)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWR"), ])[1],#
		10#
	)#
})#
# createACS#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=2)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("createACS, Are y-values of edge units equal to 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createACS, Are m-values of edge units 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("createACS, Are there duplicates units in the sample?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})#
# createRACS#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createRACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", seed=5)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("createRACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		4#
	)#
})#
test_that("createRACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		9#
	)#
})#
test_that("createRACS, Are y-values of edge units equal to 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("createRACS, Are m-values of edge units 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("createRACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
#
test_that("createRACS, Are there duplicates units in the sample?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})
head(Thompson1990Figure1Population)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
# createSRS#
test_that("1. createSRS, Does the function work when setting the seed for random sampling?", {#
	data(Thompson1990Figure1Population)#
	Z <- createSRS(Thompson1990Figure1Population, 10, seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value==2), ])[1],#
		1#
	)#
})#
test_that("2. createSRS, Does the function work without setting the seed for random sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("3. createSRS, Does the function work for without replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWOR"), ])[1],#
		10#
	)#
})#
test_that("4. createSRS, Does the function work for with replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10, replace=T)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWR"), ])[1],#
		10#
	)#
})#
# createACS#
test_that("5. createACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=2)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("6. createACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("7. createACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("8. createACS, Are y-values of edge units equal to 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("9. createACS, Are m-values of edge units 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("10. createACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("11. createACS, Are there duplicates units in the sample?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})#
# createRACS#
test_that("12. createRACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createRACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", seed=5)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("13. createRACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		4#
	)#
})#
test_that("14. createRACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		9#
	)#
})#
test_that("15. createRACS, Are y-values of edge units equal to 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("16. createRACS, Are m-values of edge units 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("17. createRACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
#
test_that("18. createRACS, Are there duplicates units in the sample?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
S <- createSRS(Thompson1990Figure1Population, 10, seed=2)
S
S <- createSRS(Thompson1990Fig1Pop, 10, seed=2)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]
S
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
Thompson1990Figure1Population
Thompson1990Figure1Population %>% filter(x=10, y=6)
Thompson1990Figure1Population %>% filter(x==10, y=6)
Thompson1990Figure1Population %>% filter(x==10, y==6)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
S[5, c("x", "y")]
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)
S
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
init <- S[, c("x", "y")]
init
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
Z <- createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init)
Z
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
createACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
Z <- createACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
createACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", #
		initsample=init)
createACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", #
		initsample=init) %>% as.data.frame
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
popdata=Thompson1990Figure1Population
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
n1=10
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
yvar="y_value"
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
initsample=init
setwd('/Users/KSauby/Documents/Projects/ACS/R')
. <- Sampling <- y_val <- NULL#
	if (is.data.frame(initsample)) {#
		S <- merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
	} else {#
		if (!is.na(seed)) {set.seed(seed)}#
		S <- createSRS(popdata=popdata, n1=n1)#
	}
S
setwd('/Users/KSauby/Documents/Projects/ACS/R')
Z = popdata %>%#
		dplyr::filter(.data$NetworkID %in% S$NetworkID) %>%#
		merge(S, all.x=T)#
	Networks = Z %>% filter(!!YVAR > condition)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
YVAR <- sym(yvar)#
	. <- Sampling <- y_val <- NULL#
	if (is.data.frame(initsample)) {#
		S <- merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
	} else {#
		if (!is.na(seed)) {set.seed(seed)}#
		S <- createSRS(popdata=popdata, n1=n1)#
	}#
	# add the rest of the units for each network in the initial sample#
	Z = popdata %>%#
		dplyr::filter(.data$NetworkID %in% S$NetworkID) %>%#
		merge(S, all.x=T)#
	Networks = Z %>% filter(!!YVAR > condition)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
condition=0
setwd('/Users/KSauby/Documents/Projects/ACS/R')
YVAR <- sym(yvar)#
	. <- Sampling <- y_val <- NULL#
	if (is.data.frame(initsample)) {#
		S <- merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
	} else {#
		if (!is.na(seed)) {set.seed(seed)}#
		S <- createSRS(popdata=popdata, n1=n1)#
	}#
	# add the rest of the units for each network in the initial sample#
	Z = popdata %>%#
		dplyr::filter(.data$NetworkID %in% S$NetworkID) %>%#
		merge(S, all.x=T)#
	Networks = Z %>% filter(!!YVAR > condition)
Networks
setwd('/Users/KSauby/Documents/Projects/ACS/R')
dim(Networks)[1] > 0
setwd('/Users/KSauby/Documents/Projects/ACS/R')
if (dim(Z[which(is.na(Z$Sampling)), ])[1] > 0) {#
			Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
		}#
		# fill in edge units#
		E = data.frame(#
			x = as.numeric(rowSums(expand.grid(Networks$x, c(1,-1,0,0)))),#
		  	y = rowSums(expand.grid(Networks$y, c(0,0,1,-1))),#
			Sampling = "Edge"#
		) %>%#
		rowwise() %>%#
		mutate(xy = paste(#
			str_pad(#
				.data$x,#
				nchar(max(popdata$x)),#
				"0",#
				side="left"#
			),#
			str_pad(#
				.data$y,#
				nchar(max(popdata$y)),#
				"0",#
				side="left"#
			)#
		)) %>%#
		ungroup()
E
setwd('/Users/KSauby/Documents/Projects/ACS/R')
Z %<>% #
			mutate(xy = paste(#
				str_pad(#
					.data$x,#
					nchar(max(popdata$x)),#
					"0",#
					side="left"#
				),#
				str_pad(#
					.data$y,#
					nchar(max(popdata$y)),#
					"0",#
					side="left"#
				)#
			)) %>%#
			ungroup()
Z
setwd('/Users/KSauby/Documents/Projects/ACS/R')
E$Sampling %<>% as.character()#
		E %<>% filter(!(.data$xy %in% Z$xy))#
		ZZ <- Z %>% #
			bind_rows(E) %>%#
			group_by(x,y) %>%#
			filter(row_number()==1)
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>% subset(#
			x %in% popdata$x &#
			y %in% popdata$y#
		)
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
dim(#
			ZZ[which(#
				is.na(#
					eval(parse(text=paste(#
						"ZZ$", #
						yvar, #
						sep=""#
					)))#
				)#
			), ])[1] > 0
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := replace(#
					y_val,#
					Sampling=="Edge",#
					0#
				),#
				m = replace(#
					m,#
					Sampling=="Edge",#
					0#
				)#
			)
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ <- Z %>% #
			bind_rows(E) %>%#
			group_by(x,y) %>%#
			filter(row_number()==1)#
		# remove plots outside of population extent#
		ZZ %<>% subset(#
			x %in% popdata$x &#
			y %in% popdata$y#
		)#
		# fill in values
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := ifelse(#
					Sampling=="Edge",#
					0,#
					yval = yval#
				)
)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := ifelse(#
					Sampling=="Edge",#
					0,#
					yval#
				)
)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := ifelse(#
					Sampling=="Edge",#
					0,#
					!!YVAR#
				)
)
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
E$Sampling %<>% as.character()#
		E %<>% filter(!(.data$xy %in% Z$xy))#
		ZZ <- Z %>% #
			bind_rows(E) %>%#
			group_by(x,y) %>%#
			filter(row_number()==1)#
		# remove plots outside of population extent#
		ZZ %<>% subset(#
			x %in% popdata$x &#
			y %in% popdata$y#
		)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := ifelse(#
					Sampling=="Edge",#
					0,#
					!!YVAR#
				),#
				m = ifelse(#
					Sampling=="Edge",#
					0,#
					m#
				)#
			)
ZZ
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create an Adaptive Cluster Sample.#
#'#
#' @param popdata The population to be sampled.#
#' @param seed A vector of numbers to feed to \code{set.seed()} so that the sampling is reproducible. Defaults to NA so that it is not necessary to specific a random number seed.#
#' @param n1 The initial sample size (sampled according to simple random sampling without replacement).#
#' @param yvar The variable of interest that is used to determine the condition under which adaptive cluster sampling takes place.#
#' @param condition Threshold value of the y variable that initiates ACS. Defaults to 0 (i.e., anything greater than 0 initiates adaptive cluster sampling).#
#' @param initsample Allows the user to specify a list of x and y coordinates of the initial sample. Defaults to "NA" so that the initial sample is selected according to simple random sampling without replacement.#
#
#' @return A restricted adaptive cluster sample.#
#
#' @examples#
#' library(ggplot2)#
#' data(Thompson1990Figure1Population)#
#' data(Thompson1990Figure1Sample)#
#' #
#' # Initiate ACS#
#' Z = createACS(#
#'	popdata=Thompson1990Fig1Pop, #
#'	seed=9, #
#'	n1=10, #
#'	yvar="y_value", #
#'	condition=0#
#')#
#' #
#' # plot ACS sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Fig1Pop, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Z, aes(x,y), shape=0, size=7)#
#' # Initiate ACS, different seed#
#' Z = createACS(popdata=Thompson1990Fig1Pop, seed=26, n1=10, yvar="y_value", condition=0)#
#' #
#' # plot ACS sample overlaid onto population#
#' ggplot() +#
#' 	geom_point(data=Thompson1990Fig1Pop, aes(x,y, size=factor(y_value),#
#' 		shape=factor(y_value))) +#
#' 	scale_shape_manual(values=c(1, rep(16, length(2:13)))) +#
#' 	geom_point(data=Z, aes(x,y), shape=0, size=7)#
#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} A Sampling Strategy Designed to Maximize the Efficiency of Data Collection of Food Web Relationships.#
#
#' @export#
#' @importFrom stringr str_pad#
#' @importFrom dplyr filter rowwise#
#' @importFrom ggplot2 ggplot#
#
createACS <- function(popdata, n1, yvar, condition=0, seed=NA, initsample=NA) {#
	YVAR <- sym(yvar)#
	. <- Sampling <- y_val <- NULL#
	if (is.data.frame(initsample)) {#
		S <- merge(popdata, initsample, all.y=TRUE) 	#
		S$Sampling <- "Primary Sample"#
	} else {#
		if (!is.na(seed)) {set.seed(seed)}#
		S <- createSRS(popdata=popdata, n1=n1)#
	}#
	# add the rest of the units for each network in the initial sample#
	Z = popdata %>%#
		dplyr::filter(.data$NetworkID %in% S$NetworkID) %>%#
		merge(S, all.x=T)#
	Networks = Z %>% filter(!!YVAR > condition)#
	# if there are units that satisfy the condition, fill in edge units#
	if (dim(Networks)[1] > 0) {#
		#Z %<>% rename(y_val = yvar)#
		# names(Z)[names(Z) == yvar] <- 'y_val'#
		#Z %<>%#
		#	as.data.table %>%#
		#	setnames(yvar, "y_val")#
		if (dim(Z[which(is.na(Z$Sampling)), ])[1] > 0) {#
			Z[which(is.na(Z$Sampling)), ]$Sampling <- "Cluster"#
		}#
		# fill in edge units#
		E = data.frame(#
			x = as.numeric(rowSums(expand.grid(Networks$x, c(1,-1,0,0)))),#
		  	y = rowSums(expand.grid(Networks$y, c(0,0,1,-1))),#
			Sampling = "Edge"#
		) %>%#
		rowwise() %>%#
		mutate(xy = paste(#
			str_pad(#
				.data$x,#
				nchar(max(popdata$x)),#
				"0",#
				side="left"#
			),#
			str_pad(#
				.data$y,#
				nchar(max(popdata$y)),#
				"0",#
				side="left"#
			)#
		)) %>%#
		ungroup()#
		Z %<>% #
			mutate(xy = paste(#
				str_pad(#
					.data$x,#
					nchar(max(popdata$x)),#
					"0",#
					side="left"#
				),#
				str_pad(#
					.data$y,#
					nchar(max(popdata$y)),#
					"0",#
					side="left"#
				)#
			)) %>%#
			ungroup()#
		E$Sampling %<>% as.character()#
		E %<>% filter(!(.data$xy %in% Z$xy))#
		ZZ <- Z %>% #
			bind_rows(E) %>%#
			group_by(x,y) %>%#
			filter(row_number()==1)#
		# remove plots outside of population extent#
		ZZ %<>% subset(#
			x %in% popdata$x &#
			y %in% popdata$y#
		)#
		# fill in values for Edge units#
		if (dim(#
			ZZ[which(#
				is.na(#
					eval(parse(text=paste(#
						"ZZ$", #
						yvar, #
						sep=""#
					)))#
				)#
			), ])[1] > 0) {#
			ZZ %<>%#
			rowwise() %>%#
			mutate(#
				!!YVAR := ifelse(#
					Sampling=="Edge",#
					0,#
					!!YVAR#
				),#
				m = ifelse(#
					Sampling=="Edge",#
					0,#
					m#
				)#
			)#
		}	#
		ZZ %<>%#
			arrange()#
		return(ZZ)#
	} else {#
		# if there are NO units that satisfy the condition, stop here and return the SRSWOR sample#
		return(Z)#
	}#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
#### TESTING#
#
# createSRS#
test_that("1. createSRS, Does the function work when setting the seed for random sampling?", {#
	data(Thompson1990Figure1Population)#
	Z <- createSRS(Thompson1990Figure1Population, 10, seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value==2), ])[1],#
		1#
	)#
})#
test_that("2. createSRS, Does the function work without setting the seed for random sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("3. createSRS, Does the function work for without replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWOR"), ])[1],#
		10#
	)#
})#
test_that("4. createSRS, Does the function work for with replacement sampling?", {#
	Z <- createSRS(Thompson1990Figure1Population, 10, replace=T)#
	expect_equal(#
		dim(Z[which(Z$Sampling=="SRSWR"), ])[1],#
		10#
	)#
})#
# createACS#
test_that("5. createACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=2)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("6. createACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	data(Thompson1990Figure1Population)#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("7. createACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createACS(#
		popdata=Thompson1990Figure1Population, #
		n1=10, #
		yvar="y_value", #
		initsample=init#
	) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		11#
	)#
})#
test_that("8. createACS, Are y-values of edge units equal to 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("9. createACS, Are m-values of edge units 0?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("10. createACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
test_that("11. createACS, Are there duplicates units in the sample?", {#
	Z <- createACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})#
# createRACS#
test_that("12. createRACS, Does the function work when providing the seed and without providing the initial sample? Example 1: no adaptive cluster sampling takes place.", {#
	data(Thompson1990Figure1Population)#
	Z <- createRACS(popdata=Thompson1990Figure1Population, n1=10, yvar="y_value", seed=5)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		0#
	)#
})#
test_that("13. createRACS, Does the function work when providing the seed and without providing the initial sample? Example 2: adaptive cluster sampling takes place", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		4#
	)#
})#
test_that("14. createRACS, Does the function work when providing the initial sample?", {#
	S <- createSRS(Thompson1990Figure1Population, 10, seed=2)#
	S[5, c("x", "y")] <- c(10,6)#
	init <- S[, c("x", "y")]#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", #
		initsample=init) #
	expect_equal(#
		dim(Z[which(Z$y_value > 0), ])[1],#
		9#
	)#
})#
test_that("15. createRACS, Are y-values of edge units equal to 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$y_value),#
		0#
	)#
})#
test_that("16. createRACS, Are m-values of edge units 0?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		unique(Z[which(Z$Sampling == "Edge"), ]$m),#
		0#
	)#
})#
test_that("17. createRACS, Does the function work when no seed or initial sample is provided?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value")#
	expect_gte(#
		dim(Z)[1],#
		10#
	)#
})#
#
test_that("18. createRACS, Are there duplicates units in the sample?", {#
	Z <- createRACS(Thompson1990Figure1Population, 10, "y_value", seed=26)#
	expect_equal(#
		dim(Z[duplicated(Z), ])[1],#
		0#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create "Wide" Format Population Summary Statistics for Population Data#
#' #
#' @param popsummarystats Created by the function calculatePopSummaryStats.#
#' @param ovar vector of occupancy variables#
#' @param rvar vector of ratio variables#
#' @return Dataframe with a column per mean/variance of each variable and a row per population.#
#' @export#
#' @examples#
#' CactusRealizationSummary <- calculatePopSummaryStats(#
#' 	popdata = CactusRealizations, #
#' 	summaryvar = c("Stricta", "Pusilla", "Cactus",#
#' 		"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
#' 		"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
#' 	popgroupvar = "population", #
#' 	rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
#' 		"Percent_Cover_Stricta", "Height_Stricta", #
#' 		"Old_Moth_Evidence_Stricta"),#
#' 	nrow=30,#
#' 	ncol=30#
#' )#
#' patch_data_summary_wide <- createWidePopSummaryStats(#
#' 	popsummarystats = CactusRealizationSummary,#
#' 	ovar = "Stricta",#
#' 	rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
#' 		"Height_Stricta", "Old_Moth_Evidence_Stricta")#
#' )#
createWidePopSummaryStats <- function(popsummarystats, ovar, rvar) {#
	# variance#
	popsummarystats[[2]]$variable %<>% as.character()#
	A <- popsummarystats[[2]] %>%#
		select(.data$Var, .data$variable, .data$population) %>%#
		mutate(#
			variable = ifelse(#
				.data$variable %in% rvar,#
				paste(.data$variable, "ratio", sep="_"),#
				.data$variable#
			)#
		) %>%#
		spread(key=variable, value=Var)#
	nvar <- length(unique(popsummarystats[[2]]$variable))#
	names(A)[2:(nvar + 1)] <- paste(names(A)[2:(nvar + 1)], "var", sep="_")#
	# mean#
	B <- popsummarystats[[2]] %>%#
		select(.data$Mean, .data$variable, .data$population) %>%#
		mutate(#
			variable = ifelse(#
				.data$variable %in% rvar,#
				paste(.data$variable, "ratio", sep="_"),#
				.data$variable#
			)#
		) %>%#
		spread(key=variable, value=Mean)#
	names(B)[2:(nvar + 1)] <- paste(names(B)[2:(nvar + 1)], "mean", sep="_")#
	# population size#
	C <- popsummarystats[[1]] %>%#
		select(.data$population, .data$N)#
	# merge all together#
	merge(A, B, by="population") %>% merge(C, by="population")#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Return the sum of a vector, after removing NAs.#
#' #
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
Sum <- function(x) {sum(x, na.rm=TRUE)}#
#
#' Return the mean of a vector with up to two decimal places, after removing NAs.#
#' #
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
Mean <- function(x) base::mean(x, na.rm=TRUE)#
#' Return the population variance of a vector, after removing NAs, and round.#
#'#
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
PopVariance <- function(x) {#
	temp <- sum((x-mean(x))^2)/length(x)#
}#
#
#' Population Coefficient of Variation#
#' #
#' @param x Vectors of data.#
#
popCV <- function(x) {sqrt(PopVariance(x))/Mean(x)}#
#
#' Calculate Summary Statistics for Patch Population Data#
#' #
#' @param population_data Data on multiple realizations of patches of the species of interest within the grid of locations (created by \code{createSpeciesPatchPopulations} function).#
#' @param summaryvar Vector of variables for which summary statistics should be calculated.#
#' @param popgroupvar String identifying the categorical variable identifying the different populations.#
#' @param rvar Vector of variables for which ratio estimators should be used.#
#' @param spatweights Vector of spatial weight matrix styles. Can take on values "W", "B", "C", "U", "S", and "minmax". See nb2listw for more details.#
#
#' @description Calculates summary statistics for patch population data.#
#
#' @return Dataframe including summary statistics for each column identified in \code{summaryvar} and for each category identified in \code{popgroupvar}.#
#
#' @export#
#' @importFrom dplyr ungroup sym group_by_at#
#' @importFrom stringr str_sub#
#' @importFrom stats var#
#' @importFrom sp coordinates#
#' @importFrom spdep cell2nb nb2listw joincount.test moran.test #
#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' ovar = c(#
#' 	"Stricta",#
#' 	"Pusilla",#
#' 	"Cactus",#
#' 	"CACA_on_Pusilla",#
#' 	"CACA_on_Stricta",#
#' 	"MEPR_on_Pusilla",#
#' 	"MEPR_on_Stricta",#
#' 	"Old_Moth_Evidence_Pusilla",#
#' 	"Old_Moth_Evidence_Stricta"#
#' 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
#' 	# "Percent_Cover_Stricta",#
#' 	# "Height_Pusilla",#
#' 	# "Height_Stricta",#
#' )		#
#' summaryvar = ovar#
#' # WHAT WAS I THINK HERE? for grouping variables?#
#' popgroupvar = "n.networks" # c("n.networks", "realization")#
#' # create realizations#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' n.networks = c(5, 15, 10, 20, 30, 40)#
#' n.realizations = 1#
#' SpeciesInfo = PlotSurveys_season1#
#' start.seed=1#
#' buffer=5#
#' rvar = c("CACA_on_Stricta", "CACA_on_Pusilla")#
#' cactus.realizations <- createSpeciesPatchRealizations(x_start, x_end,#
#' 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, start.seed,#
#' 	ovar)#
#' patch_data_summary <- calculatePopulationSummaryStatistics(cactus.realizations, #
#' 	summaryvar=ovar, popgroupvar=popgroupvar, nrow=30, ncol=30)#
calculatePopSummaryStats <- function(#
	popdata, #
	summaryvar, #
	rvar=NULL, #
	popgroupvar,#
	spatweights="S",#
	nrow,#
	ncol#
) {#
	POPVAR <- sym(popgroupvar)#
	popdata %<>% arrange(!!POPVAR)#
	# for each popgroupvar combo, calculate summary statistics for m and number of species patches#
	# this calculates the m statistics for the unique Network sizes#
	Y1 <- popdata %>%#
		group_by_at(c("NetworkID", popgroupvar)) %>%#
		summarise(m = .data$m[1]) %>%#
		group_by_at(popgroupvar) %>%#
		summarise(#
			m_min_unique_neigh = min(.data$m),#
			m_max_unique_neigh = max(.data$m),#
			m_mean_unique_neigh = mean(.data$m),#
			m_var_unique_neigh = var(.data$m),#
			n_Species_Patches = #
				length(unique(.data$NetworkID[which(.data$m>1)]))#
		) %>%#
		ungroup %>%#
		as.data.frame#
	# this calculates the m statistics for all units#
	Y2 = popdata %>%#
	group_by_at(popgroupvar) %>%#
		summarise(#
			m_min = min(.data$m),#
			m_max = max(.data$m),#
			m_mean = mean(.data$m),#
			m_var = var(.data$m)#
		) %>%#
		ungroup %>%#
		as.data.frame#
	Z = popdata %>%#
		group_by_at(popgroupvar) %>%#
		summarise(N = length(.data$m)) %>%#
		ungroup %>%#
		as.data.frame#
	Y1 %<>% #
		merge(Y2, by=popgroupvar) %>%#
		merge(Z, by=popgroupvar)	#
	# spatial statistics and other characteristics of variables#
	A <- list()#
	popvar <- paste(#
		"popdata$", #
		popgroupvar, #
		sep=""#
	)#
	for (i in 1:length(unique(eval(parse(text=popvar))))) {#
		temp <- popdata %>%#
			filter(!!POPVAR == unique(!!POPVAR)[i])#
		temp %<>% arrange(.data$x,.data$y)#
		# spatial statistics#
		coordinates(temp) = ~ x + y#
		A[[i]] <- list()#
		for (j in 1:length(summaryvar)) {#
			A[[i]][[j]] <- data.frame(variable = summaryvar[j])#
			if (summaryvar[j] %in% rvar) {#
				temp_ratio <- temp %>% as.data.frame#
				temp_ratio %<>% #
					.[.[colnames(.)==str_sub(summaryvar[j],-7,-1)]==1, ]	#
				tempvar <- eval(parse(text =#
						paste("temp_ratio$", summaryvar[j], sep="")#
					))#
				coordinates(temp_ratio) = ~ x + y#
			} else {#
				tempvar <- eval(parse(text =#
					paste("temp$", summaryvar[j], sep="")#
				))	#
			}#
			A[[i]][[j]]$Mean_tempvar 	<- Mean(tempvar)#
			A[[i]][[j]]$Var_tempvar 	<- PopVariance(tempvar)#
			A[[i]][[j]]$CV_tempvar 		<- popCV(tempvar)#
			A[[i]][[j]]$Total_tempvar 	<- Sum(tempvar)#
			A[[i]][[j]]$SSQ_R			<- calculateSSQR(#
				popdata = as.data.frame(temp),#
				variable = summaryvar[j],#
				popgroupvar#
			)$SSQ_R#
			# for join counts and moran's i, change NAs in rvar's to zeros#
			temp2 <- temp#
			temp2@data[rvar][is.na(temp2@data[rvar])] <- 0#
			if (length(tempvar[which(tempvar > 0)]) > 0) {#
				# join counts and moran's i#
				nb <- cell2nb(nrow = nrow, ncol = ncol)#
				if ("W" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "W") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.W <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.W <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}#
				if ("B" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "B") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.B <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.B <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("C" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "C") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.C <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.C <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("U" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "U") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.U <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.U <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("S" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "S") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.S <- joincount.test(as.factor(#
						# NEED TO FIGURE OUT HOW TO GET RID OF NAs#
						# OR CAN YOU JUST NOT DO JOINT COUNT TEST FOR RVAR#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.S <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("minmax" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "minmax") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.minmax <- joincount.test(#
						as.factor(eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.minmax <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
			} else {#
				if ("W" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.W <- NA#
					A[[i]][[j]]$MoranI.W <- NA#
				}#
				if ("B" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.B <- NA#
					A[[i]][[j]]$MoranI.B <- NA#
				}	#
				if ("C" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.C <- NA#
					A[[i]][[j]]$MoranI.C <- NA#
				}	#
				if ("U" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.U <- NA#
					A[[i]][[j]]$MoranI.U <- NA#
				}	#
				if ("S" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.S <- NA#
					A[[i]][[j]]$MoranI.S <- NA#
				}	#
				if ("minmax" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.minmax <- NA#
					A[[i]][[j]]$MoranI.minmax <- NA#
				}	#
			}#
		}#
		A[[i]] <- do.call(rbind.data.frame, A[[i]])#
		A[[i]]$population <- unique(eval(parse(#
			text=paste(#
				"popdata$", #
				popgroupvar, #
				sep=""#
			)#
		)))[i]#
	}#
	B <- do.call(rbind.data.frame, A)#
	B %<>% arrange(variable, population) %>%#
		dplyr::rename(#
			Mean = Mean_tempvar,#
			Var = Var_tempvar,#
			CV = CV_tempvar,#
			Total = Total_tempvar#
		)#
	return(list(Y1, B))#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calculatePopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 6, SamplingDesign=ACS, N.SRSWOR.plots==100", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_6 <- patch_data_summary_wide %>% filter(population==6)#
	# WHERE DOES SIMULATION DATA COME FROM#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_6$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RB_Stricta <- 100 * (#
		mean(temp_sim_data$Stricta_mean_observed) - population_6$Stricta_mean#
	) / population_6$Stricta_mean#
	RE_Stricta <- (#
		population_6$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_6$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RB_CACA_on_Stricta <- 100 * (#
		mean(temp_sim_data$CACA_on_Stricta_ratio_mean_observed) - #
		population_6$CACA_on_Stricta_ratio_mean#
	) / population_6$CACA_on_Stricta_ratio_mean#
	RB_MEPR_on_Stricta <- 100 * (#
		mean(temp_sim_data$MEPR_on_Stricta_ratio_mean_observed) - #
		population_6$MEPR_on_Stricta_ratio_mean#
	) / population_6$MEPR_on_Stricta_ratio_mean#
	RB_Old_Moth_Evidence_Stricta <- 100 * (#
		mean(temp_sim_data$Old_Moth_Evidence_Stricta_ratio_mean_observed) - #
		population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	) / population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	RE_CACA_on_Stricta <- (#
		population_6$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta <- (#
		population_6$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta <- (#
		population_6$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias <- calculateSamplingBias(#
		population_data_summary	= population_6, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_6,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#	 	RB#
	expect_equal(#
		RB_Stricta,#
		example_bias$Stricta_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RB#
	expect_equal(#
		RB_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 1, SamplingDesign=ACS, N.SRSWOR.plots==40", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_1 <- patch_data_summary_wide %>% filter(population==1)#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==1, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==40#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==1, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==40,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_1$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RE_Stricta = (#
		population_1$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_1$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RE_CACA_on_Stricta = (#
		population_1$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta = (#
		population_1$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta = (#
		population_1$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias = calculateSamplingBias(#
		population_data_summary	= population_1, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_1,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 1, SamplingDesign=RACS with new_y_HT formula, N.SRSWOR.plots==40", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		PopulationSummaryStatistics = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_1 <- patch_data_summary_wide %>% filter(population==1)#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simdata_new_yHT_re %>% filter(#
		population==1, #
		SamplingDesign=="RACS", #
		N.SRSWOR.plots==40#
	)#
	temp_sim_data_ratio <- simdata_new_yHT_re %>% filter(#
		population==1, #
		SamplingDesign=="RACS", #
		N.SRSWOR.plots==40,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_1$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RE_Stricta = (#
		population_1$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_1$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RE_CACA_on_Stricta = (#
		population_1$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta = (#
		population_1$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta = (#
		population_1$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias = calculateSamplingBias(#
		population_data_summary	= population_1, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_1,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
CactusRealizationSummary <- calculatePopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)
head(CactusRealizations)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create the population displayed in Figure 1 from Thompson (1990)#
#' #
#' @return The population displayed in Figure 1 from Thompson (1990).#
#' @examples #
#' library(ggplot2)#
#' library(magrittr)#
#' library(dplyr)#
#' Thompson1990Fig1Pop <- createThompson1990Fig1Pop()#
#' p <- ggplot(Thompson1990Fig1Pop %>% filter(m>1), aes(x, y, #
#' 	colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=1, xmax=20, ymin=1, ymax=20, alpha=0, #
#' colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	scale_colour_gradientn(colours = rainbow(7))#
#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' Thompson, S. (1990). Adaptive Cluster Sampling. \emph{Journal of the American Statistical Association}, 85(412): 1050--1059.#
#' @export#
#
createThompson1990Fig1Pop <- function() {#
	y_value <- NetworkID <- x <- y <- m <- NULL#
	# create population#
	empty = rep(0,20)#
	P = rbind(#
		c(rep(0,4),5,13,3,rep(0,13)),#
		c(rep(0,4),2,11,2,rep(0,13)),#
		as.data.frame(sapply(empty, rep, 11)), # rows 3-13#
		c(rep(0,9),3,1,rep(0,9)),#
		c(rep(0,8),5,39,10,rep(0,9)),#
		c(rep(0,8),5,13,4,rep(0,9)),#
		c(rep(0,7),2,22,3,rep(0,10)),#
		c(rep(0,12),10,8,rep(0,6)),#
		c(rep(0,12),7,22,rep(0,6)),#
		c(rep(0,20))#
	)#
	# add x and y coordinates#
	P = cbind(#
		expand.grid(x = rev(1:20), y = 1:20), #
		y_value = as.vector(unlist(P))#
		) #%>%#
		#filter(y_value > 0)#
	names(P)[1:2] <- c("y", "x")#
	# assign network membership of units containing the species of interest#
	P_networks <- assignNetworkMembership(P %>% filter(y_value > 0), plot.size=1)#
	# fill in m values#
	P = merge(P, P_networks, all=T)#
	P[which(P$y_value==0), ]$m <- 1#
	# fill in NetworkIDs#
	maxID <- max(P$NetworkID, na.rm=T)#
	P[which(is.na(P$NetworkID)), ]$NetworkID <- seq(from=(maxID + 1), #
		to=(maxID + length(which(is.na(P$NetworkID)))), by=1)#
	P %<>% #
		arrange(NetworkID) %>%#
		dplyr::select(x, y, NetworkID, m, y_value)#
	return(P)#
}
setwd('/Users/KSauby/Documents/Projects/ACS/R')
Thompson1990Fig1Pop <- createThompson1990Fig1Pop()
head(Thompson1990Fig1Pop)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Change NA values to 0.#
#'#
#' @param x Vector of data.#
#
NA_is_Zero_Function <- function(x){	#
	x[which(is.na(x))] <- 0#
	return(x)#
}#
#' Create Cactus Realization Data#
#' #
#' @param PlotSurveys_season1 Plot survey data from season 1.#
#' @param ovar occupancy variables.#
#' @return The data from Sauby and Christman.#
#' @examples #
#' library(ggplot2)#
#' CactusRealizations <- createCactusRealizations(#
#' 	PlotSurveys_season1, #
#' 	ovar = c(#
#' 	"Stricta",#
#' 	"Pusilla",#
#' 	"Cactus",#
#' 	"CACA_on_Pusilla",#
#' 	"CACA_on_Stricta",#
#' 	"MEPR_on_Pusilla",#
#' 	"MEPR_on_Stricta",#
#' 	"Old_Moth_Evidence_Pusilla",#
#' 	"Old_Moth_Evidence_Stricta"#
#' 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
#' 	# "Percent_Cover_Stricta",#
#' 	# "Height_Pusilla",#
#' 	# "Height_Stricta",#
#' )		#
#' )#
#' ggplot(#
#' 	CactusRealizations,#
#' 	aes(#
#' 		x, #
#' 		y, #
#' 		shape = factor(Cactus)#
#' )) +#
#' 	geom_point() +#
#' 	facet_wrap(~population) +#
#' 	scale_shape_manual(values=c(4,16))#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @export#
#
createCactusRealizations <- function(PlotSurveys_season1, ovar) {#
	# REALIZATION DATA#
	x_start 		<- 1#
	x_end 			<- 30#
	y_start 		<- 1#
	y_end 			<- 30#
	n.networks 		<- c(5, 15, 10, 20, 30, 40)#
	n.realizations 	<- 1#
	SpeciesInfo 	<- PlotSurveys_season1#
	buffer			<- 5#
	start.seed		<- 1#
	variables		<- ovar#
	# CREATE REALIZATIONS#
	patch_data <- createRealizations(#
		x_start, #
		x_end,#
		y_start, #
		y_end, #
		buffer, #
		n.networks, #
		n.realizations, #
		SpeciesInfo, #
		start.seed,#
		variables#
	)#
	colnames(patch_data)[names(patch_data) == "n.networks"] <- "population"#
	patch_data$population %<>% as.factor()#
	levels(patch_data$population) <- 1:6#
	# convert NAs to zeros#
	 patch_data[,c(#
	 	"CACA_on_Pusilla",#
	 	"CACA_on_Stricta",#
	 	"MEPR_on_Pusilla",#
	 	"MEPR_on_Stricta",#
	 	"Old_Moth_Evidence_Pusilla",#
	 	"Old_Moth_Evidence_Stricta",#
	 	"Percent_Cover_Pusilla",#
	 	"Percent_Cover_Stricta",#
	 	"Height_Pusilla",#
	 	"Height_Stricta"#
	 )] %<>% apply(., 2, NA_is_Zero_Function)#
	 return(patch_data)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
createCactusRealizations <- function(PlotSurveys_season1, ovar) {#
	# REALIZATION DATA#
	x_start 		<- 1#
	x_end 			<- 30#
	y_start 		<- 1#
	y_end 			<- 30#
	n.networks 		<- c(5, 15, 10, 20, 30, 40)#
	n.realizations 	<- 1#
	SpeciesInfo 	<- PlotSurveys_season1#
	buffer			<- 5#
	start.seed		<- 1#
	variables		<- ovar#
	# CREATE REALIZATIONS#
	patch_data <- createRealizations(#
		x_start, #
		x_end,#
		y_start, #
		y_end, #
		buffer, #
		n.networks, #
		n.realizations, #
		SpeciesInfo, #
		start.seed,#
		variables#
	)#
	colnames(patch_data)[names(patch_data) == "n.networks"] <- "population"#
	patch_data$population %<>% as.factor()#
	levels(patch_data$population) <- 1:6#
	# convert NAs to zeros#
	 patch_data[,c(#
	 	"CACA_on_Pusilla",#
	 	"CACA_on_Stricta",#
	 	"MEPR_on_Pusilla",#
	 	"MEPR_on_Stricta",#
	 	"Old_Moth_Evidence_Pusilla",#
	 	"Old_Moth_Evidence_Stricta",#
	 	"Percent_Cover_Pusilla",#
	 	"Percent_Cover_Stricta",#
	 	"Height_Pusilla",#
	 	"Height_Stricta"#
	 )] %<>% apply(., 2, NA_is_Zero_Function)#
	 return(patch_data)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create multiple realizations from data#
#
#' @param x_start The most western coordinate of the grid.#
#' @param x_end The most eastern coordinate of the grid.#
#' @param y_start The most southern coordinate of the grid.#
#' @param y_end The most northern coordinate of the grid.#
#' @param buffer The distance from the edge of the grid from which initial samples should not be taken.#
#' @param n.networks The number of networks to be placed in the realization.#
#' @param n.realizations The number of realizations to create per \code{n.networks}.#
#' @param SpeciesInfo A dataframe of x and y coordinates and associated species information. Should only include plots that have the species of interest.#
#' @param start.seed The initial number used in \code{set.seed}. All subsequent numbers used in set.seed will be incremental after this number. seed = seq(start.seed, start.seed + 2*n.realizations +  sum(n.networks)*n.realizations*2 + 1, by=1)#
#' @param variables Dataframe column names that are included in the final patch realizations. These columsn are given a value of "0" if the species is not present or NA.#
#' @description This function creates multiple realizations of patches of the species of interest within the grid of locations created with \code{createPopulation}.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' library(ggplot2)#
#' # EXAMPLE 1#
#' # how large does the buffer need to be when generating realizations? (so #
#' #	that network units are not truncated by the dimensions of the realization #
#' #	grid)#
#' data(PlotSurveys_season1)#
#' PlotSurveys_season1 %>%#
#'	as.data.frame %>%#
#' 	summarise(#
#' 		max_x_buffer = max(abs(Rel_x)),#
#' 		max_y_buffer = max(abs(Rel_y))#
#' 	)#
#' #
#' # realization info#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' n.networks = c(5, 15, 10, 20, 30, 40)#
#' n.realizations = 1#
#' SpeciesInfo = PlotSurveys_season1#
#' variables = c("Stricta", "Pusilla", "Cactus")#
#' start.seed=1#
#' buffer=5#
#' #
#' # create realizations#
#' CactusRealizations = createSpeciesPatchRealizations(x_start, x_end, #
#' 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, start.seed,#
#' 	variables)#
#' #
#' # plot realizations#
#' p <- ggplot(CactusRealizations, aes(x, y, colour=NetworkID, #
#'		label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(CactusRealizations %>% filter(m>1), aes(x, y, colour=NetworkID,#
#'	 	label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' # EXAMPLE 2#
#' #
#' # realization info	#
#' x_start = 1#
#' x_end = 20#
#' y_start = 1#
#' y_end = 20#
#' n.networks = c(1,2,3)#
#' n.realizations = 1#
#' SpeciesInfo = Thompson1990Fig1Pop %>% #
#' 	filter(m > 1) %>% #
#' 	createNetworks#
#' variables = "y_value"#
#' buffer=5#
#' start.seed=1#
#' #
#' # create realizations#
#' Thompson.realizations = createRealizations(x_start, x_end,#
#'	 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, #
#'		start.seed, variables)	#
#' #
#' # plot realizations#
#' p <- ggplot(Thompson.realizations, aes(x, y, colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end, #
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(Thompson.realizations %>% filter(m > 1), aes(x, y, #
#'		colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#' @export#
#
createRealizations <- function(#
	x_start, #
	x_end, #
	y_start, #
	y_end, #
	buffer, #
	n.networks, #
	n.realizations, #
	SpeciesInfo, #
	start.seed, #
	variables#
)#
{#
	x <- y <- Rel_x <- Rel_y <- NetworkID <- m <- NULL#
	network.length = length(n.networks)#
	seed = seq(start.seed, start.seed + 2*n.realizations + #
		sum(n.networks)*n.realizations*2 + 1, by=1)#
    grid <- createPopulation(#
		x_start + buffer, #
		x_end - buffer, #
		y_start + buffer, #
		y_end - buffer#
	)#
	patch.array <- vector("list", network.length)#
	for (i in 1:length(n.networks)) { 	#
		patch.array[[i]] <- list()#
		for (j in 1:n.realizations) { 			#
			patch = createSpeciesPatch(#
				grid, #
				n.networks[i], #
				seed, #
				cluster.info=SpeciesInfo, #
				x=x, #
				y=y, #
				Rel_x=Rel_x, #
				Rel_y=Rel_y#
			)	#
			# fill in absence data#
			population = createPopulation(#
				x_start, #
				x_end, #
				y_start, #
				y_end#
			)#
			patch %<>% merge(population, by=c("x", "y"), all=T)#
			for (k in 1:length(variables)) {#
				patch[which(is.na(patch[,variables[k]])), #
					variables[k]] <- 0#
			}#
			patch[which(is.na(patch$NetworkID)), ]$NetworkID <- seq(#
				max(patch$NetworkID, na.rm=T) + 1,#
				length(patch[which(is.na(patch$NetworkID)), ]$NetworkID) + #
					max(patch$NetworkID, na.rm=T), #
				by=1#
			) #
			# other info#
			patch.array[[i]][[j]] <- patch#
			patch.array[[i]][[j]]$n.networks <- n.networks[i]#
			patch.array[[i]][[j]]$realization <- j#
			# fill in missing m values#
			patch.array[[i]][[j]] %<>% #
				group_by(NetworkID) %>% #
				mutate(m = length(m))#
		}#
		max.seed = max(patch$rotation.seed, na.rm=T)#
		if (is.na(n.networks[i+1])) {seed = NA} else {#
			seed = seq(max.seed, max.seed + 2*n.realizations + #
				sum(n.networks)*n.realizations*2 + 1, by=1)#
		}#
	}	#
	# compress list of patch data to dataframe#
	patch_data = do.call(rbind.fill, unlist(patch.array, recursive=F))#
	patch_data$N = dim(population)[1]#
	return(patch_data)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create a population of locations (in a grid). #
#' #
#' @param x_start The most western coordinate of the grid.#
#' @param x_end The most eastern coordinate of the grid.#
#' @param y_start The most southern coordinate of the grid.#
#' @param y_end The most northern coordinate of the grid.#
#' @return A grid of locations with coordinates (x, y).#
#' @export#
#
#' @examples population <- createPopulation(x_start = 5, x_end = 27, y_start = 5, y_end = 27)#
#
createPop <- function(x_start, x_end, y_start, y_end) {#
  data.frame(expand.grid(#
    x = 	x_start:x_end,#
    y = 	y_start:y_end#
  )) # %>%#
  # mutate(unitID = 1:length(x))#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create multiple realizations from data#
#
#' @param x_start The most western coordinate of the grid.#
#' @param x_end The most eastern coordinate of the grid.#
#' @param y_start The most southern coordinate of the grid.#
#' @param y_end The most northern coordinate of the grid.#
#' @param buffer The distance from the edge of the grid from which initial samples should not be taken.#
#' @param n.networks The number of networks to be placed in the realization.#
#' @param n.realizations The number of realizations to create per \code{n.networks}.#
#' @param SpeciesInfo A dataframe of x and y coordinates and associated species information. Should only include plots that have the species of interest.#
#' @param start.seed The initial number used in \code{set.seed}. All subsequent numbers used in set.seed will be incremental after this number. seed = seq(start.seed, start.seed + 2*n.realizations +  sum(n.networks)*n.realizations*2 + 1, by=1)#
#' @param variables Dataframe column names that are included in the final patch realizations. These columsn are given a value of "0" if the species is not present or NA.#
#' @description This function creates multiple realizations of patches of the species of interest within the grid of locations created with \code{createPopulation}.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' library(ggplot2)#
#' # EXAMPLE 1#
#' # how large does the buffer need to be when generating realizations? (so #
#' #	that network units are not truncated by the dimensions of the realization #
#' #	grid)#
#' data(PlotSurveys_season1)#
#' PlotSurveys_season1 %>%#
#'	as.data.frame %>%#
#' 	summarise(#
#' 		max_x_buffer = max(abs(Rel_x)),#
#' 		max_y_buffer = max(abs(Rel_y))#
#' 	)#
#' #
#' # realization info#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' n.networks = c(5, 15, 10, 20, 30, 40)#
#' n.realizations = 1#
#' SpeciesInfo = PlotSurveys_season1#
#' variables = c("Stricta", "Pusilla", "Cactus")#
#' start.seed=1#
#' buffer=5#
#' #
#' # create realizations#
#' CactusRealizations = createSpeciesPatchRealizations(x_start, x_end, #
#' 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, start.seed,#
#' 	variables)#
#' #
#' # plot realizations#
#' p <- ggplot(CactusRealizations, aes(x, y, colour=NetworkID, #
#'		label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(CactusRealizations %>% filter(m>1), aes(x, y, colour=NetworkID,#
#'	 	label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' # EXAMPLE 2#
#' #
#' # realization info	#
#' x_start = 1#
#' x_end = 20#
#' y_start = 1#
#' y_end = 20#
#' n.networks = c(1,2,3)#
#' n.realizations = 1#
#' SpeciesInfo = Thompson1990Fig1Pop %>% #
#' 	filter(m > 1) %>% #
#' 	createNetworks#
#' variables = "y_value"#
#' buffer=5#
#' start.seed=1#
#' #
#' # create realizations#
#' Thompson.realizations = createRealizations(x_start, x_end,#
#'	 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, #
#'		start.seed, variables)	#
#' #
#' # plot realizations#
#' p <- ggplot(Thompson.realizations, aes(x, y, colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end, #
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(Thompson.realizations %>% filter(m > 1), aes(x, y, #
#'		colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#' @export#
#
createRealizations <- function(#
	x_start, #
	x_end, #
	y_start, #
	y_end, #
	buffer, #
	n.networks, #
	n.realizations, #
	SpeciesInfo, #
	start.seed, #
	variables#
)#
{#
	x <- y <- Rel_x <- Rel_y <- NetworkID <- m <- NULL#
	network.length = length(n.networks)#
	seed = seq(start.seed, start.seed + 2*n.realizations + #
		sum(n.networks)*n.realizations*2 + 1, by=1)#
    grid <- createPop(#
		x_start + buffer, #
		x_end - buffer, #
		y_start + buffer, #
		y_end - buffer#
	)#
	patch.array <- vector("list", network.length)#
	for (i in 1:length(n.networks)) { 	#
		patch.array[[i]] <- list()#
		for (j in 1:n.realizations) { 			#
			patch = createSpeciesPatch(#
				grid, #
				n.networks[i], #
				seed, #
				cluster.info=SpeciesInfo, #
				x=x, #
				y=y, #
				Rel_x=Rel_x, #
				Rel_y=Rel_y#
			)	#
			# fill in absence data#
			population = createPopulation(#
				x_start, #
				x_end, #
				y_start, #
				y_end#
			)#
			patch %<>% merge(population, by=c("x", "y"), all=T)#
			for (k in 1:length(variables)) {#
				patch[which(is.na(patch[,variables[k]])), #
					variables[k]] <- 0#
			}#
			patch[which(is.na(patch$NetworkID)), ]$NetworkID <- seq(#
				max(patch$NetworkID, na.rm=T) + 1,#
				length(patch[which(is.na(patch$NetworkID)), ]$NetworkID) + #
					max(patch$NetworkID, na.rm=T), #
				by=1#
			) #
			# other info#
			patch.array[[i]][[j]] <- patch#
			patch.array[[i]][[j]]$n.networks <- n.networks[i]#
			patch.array[[i]][[j]]$realization <- j#
			# fill in missing m values#
			patch.array[[i]][[j]] %<>% #
				group_by(NetworkID) %>% #
				mutate(m = length(m))#
		}#
		max.seed = max(patch$rotation.seed, na.rm=T)#
		if (is.na(n.networks[i+1])) {seed = NA} else {#
			seed = seq(max.seed, max.seed + 2*n.realizations + #
				sum(n.networks)*n.realizations*2 + 1, by=1)#
		}#
	}	#
	# compress list of patch data to dataframe#
	patch_data = do.call(rbind.fill, unlist(patch.array, recursive=F))#
	patch_data$N = dim(population)[1]#
	return(patch_data)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create patches of species of interest within the grid population.#
#' @param n.networks Number of networks to sample from the population of networks.#
#' @param Rel_x The distance of a plot from the center of the network to which it belongs on the x axis#
#' @param Rel_y The distance of a plot from the center of the network to which it belongs on the y axis#
#' @param grid A dataframe of x and y coordinates (can be created with \code{createPopulation}). Should only include plots that have the species of interest.#
#' @param seed Vector of numbers to be given to \code{set.seed()}. Two numbers are used: the first to determine the sample of locations and the second to determine the sample of species information to be assigned to the sample locations.#
#' @param cluster.info Dataframe of all network plots except for the center plot (which is included in the cluster.centers dataframe). The dataframe should, at a miminum, include fields with information about the species used to initiate ACS, a PlotID field, a NetworkID field, and x and y coordinates.#
#' @param x X coodinate. Default is "x."#
#' @param y Y Coordinate. Default is "y."#
#' @description This function creates patches of the species of interest within the grid of locations created with \code{createPopulation}. First, it randomly determines the locations of network centers and randomly assigns species information to those locations (\code{sampleGridPopulation}), randomly rotates thet network orientation to further randomize the real data, then adds the rest of the neighbor plots. Finally, it assigns each plot a Network ID (using \code{assignNetworkMembership}; it is important to include this function in case networks overlap and must be given a new network ID).#
#' #
#' If species information is assigned twice to a given unit (as can happen in the case of overlapping, neighboring networks), the unit will be preferentially assigned the information where the species is present (if only one of the duplicate records has the species as present). If there are more than one records indicating the species is present, one of the duplicate records is randomly drawn and then assigned to the unit.#
#' #
#' The function returns a list, the first object being the list of units occupied by the species within the population, and the second object being a vector of the remaining, unused seed numbers.#
#'#
#' This function uses a maximum of \code{2 + n.networks} random numbers: the first to set the seed to sample locations from a grid, and the second to sample networks to assign to those locations (more specifically, the centers of the networks are assigned to those locations). Then a maximum of \code{n.networks} random numbers are used, each number to randomly rotate a network of units before it is assigned coordinates.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @export#
#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' library(ggplot2)#
#' # realization info#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' buffer = 5#
#' grid <- createPopulation(#
#' 	x_start + buffer, #
#' 	x_end - buffer, #
#' 	y_start + buffer, #
#' 	y_end - buffer#
#' )#
#' n.networks = 3#
#' seed = 2000:2100#
#' data(Thompson1990Fig1Pop)#
#' cluster.info = Thompson1990Fig1Pop %>% #
#' 	filter(m > 1) %>%#
#' 	createNetworks#
#' #
# create realization#
#' Thompson1990_realization = createSpeciesPatch(grid, n.networks, seed, #
#' 	cluster.info, x=x, y=y, Rel_x=Rel_x, Rel_y=Rel_y)#
#' #
#' # plot realization#
#' library(ggplot2)#
#' p <- ggplot(Thompson1990_realization, aes(x, y, colour=NetworkID, #
#' 	label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end, #
#' alpha=0, colour="grey") + #
#'  	geom_point(aes(size=factor(y_value))) + #
#'  	scale_colour_gradientn(colours = rainbow(7)) +#
#'  	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#
createSpeciesPatch <- function(grid, n.networks, seed, cluster.info, x=x, y=y, Rel_x=Rel_x, Rel_y=Rel_y) {#
	NetworkID <- temp_coords <- NULL#
	cluster.centers <- filter(cluster.info, Rel_x==0 & Rel_y==0)#
	# determine locations and species information for stage 1 plots#
	n1plots = sampleGridPop(grid, n.networks, cluster.centers, seed)#
	seed = seed[-(1:2)]#
	# create list of cluster plots and their coordinates#
	Z <- vector("list", length(unique(n1plots$NetworkID)))#
	for (i in 1:length(unique(n1plots$NetworkID))) {#
		# n1plot plot[i] at center of cluster#
		S = n1plots[which(n1plots$NetworkID == unique(n1plots$NetworkID)[i]), ]#
    	# cluster neighbors#
    	Clusters = cluster.info[which(cluster.info$NetworkID == #
			unique(n1plots$NetworkID)[i]), ]#
    	# further randomize real data by rotating clusters#
    	# max number of unique rotation.seeds = n.networks#
		Clusters$rotation.seed <- seed[i]#
    	set.seed(seed[i])#
    	rotation = sample(c(0, 90, 180, 270), 1)#
    	seed <- seed[-1]#
    	Clusters$rotation <- rotation#
    	# determine cluster plot coordinates	#
		if (rotation==0){#
			Clusters$x = Clusters$Rel_x + S$x#
			Clusters$y = Clusters$Rel_y + S$y#
		} else #
    	if (rotation==90) {#
			Clusters$x = -Clusters$Rel_y + S$x#
			Clusters$y = Clusters$Rel_x + S$y#
      	} else#
      	if (rotation==180) {#
			Clusters$x = -Clusters$Rel_x + S$x#
		    Clusters$y = -Clusters$Rel_y + S$y#
      	} else#
	  	if (rotation==270) {#
			Clusters$x = Clusters$Rel_y + S$x#
			Clusters$y = -Clusters$Rel_x + S$y#
		}#
		Z[[i]] <- Clusters#
	}#
  	H <- do.call(rbind.data.frame, Z)#
  	# merge list of cluster plots with list of SRSWOR plots#
  	H %<>%#
		rbind.fill(n1plots) %>%#
    	mutate(temp_coords = paste(x, y, sep="_")) #
	#	remove duplicates#
    Y <- as.data.frame(matrix(NA,1,dim(H)[2]))#
    for (i in 1:length(unique(H$temp_coords))) {#
      	# pull information based on x, y combo#
      	L = H[which(H$temp_coords == unique(H$temp_coords)[i]), ]#
      	# if only one row of information#
      	if (dim(L)[1]==1) {Y[i, ] = L} else {#
        # if more than one row, randomly choose a row#
            Y[i, ] = L[sample(1:dim(L)[1], size=1), ]#
		}#
    }#
    names(Y) <- names(H)#
   	Y %<>% #
   		dplyr::select(-c(NetworkID, temp_coords)) %>%#
		assignNetworkMembership(1)#
	return(Y)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Select a sample of cells from the grid population and randomly assign species information.#
#' @param grid A dataframe of x and y coordinates (can be created with \code{createPopulation}).#
#' @param n.networks Initial sample size that determines the relative density of the species.#
#' @param cluster.centers Dataframe including x and y coordinates and network IDs for the centers of clusters.#
#' @param seed Vector of numbers to be given to \code{set.seed()}. Two numbers are used: the first to determine the sample of locations and the second to determine the sample of species information to be assigned to the sample locations.#
#' @description This function uses two random numbers: the first to set the seed to sample locations from a grid, and the second to sample networks to assign to those locations (more specifically, the centers of the networks are assigned to those locations).#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' #
#' @examples#
# EXAMPLE 1#
#' library(magrittr)#
#' library(dplyr)#
#' grid = createPopulation(0, 25, 0, 25)#
#' n.networks = 2#
#' data(Thompson1990Figure1Population)#
#' cluster.info = Thompson1990Figure1Population %>% #
#' 	filter(m > 1) %>%#
#' 	createNetworks#
#' cluster.centers = filter(cluster.info, Rel_x==0 & Rel_y==0) %>%#
#' dplyr::select(-c(x,y))#
#' seed = 1:2#
#' sampleGridPopulation(grid, n.networks, cluster.centers, seed)#
#' @export#
#
sampleGridPop <- function(grid, n.networks, cluster.centers, seed) {#
  # determine locations#
  set.seed(seed[1])#
  gridsample <- grid[sample(x = 1:dim(grid)[1], size = n.networks), ]#
  gridsample$location.seed <- seed[1]#
  # determine attributes of samples#
  set.seed(seed[2])#
  species <- cluster.centers[sample(x = 1 : dim(cluster.centers)[1], size = n.networks), ] %>% as.data.frame#
  gridsample$SpeciesInfo.seed <- seed[2]#
  # merge location and attributes#
  gridsample = cbind(gridsample, species)#
  return(gridsample)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create multiple realizations from data#
#
#' @param x_start The most western coordinate of the grid.#
#' @param x_end The most eastern coordinate of the grid.#
#' @param y_start The most southern coordinate of the grid.#
#' @param y_end The most northern coordinate of the grid.#
#' @param buffer The distance from the edge of the grid from which initial samples should not be taken.#
#' @param n.networks The number of networks to be placed in the realization.#
#' @param n.realizations The number of realizations to create per \code{n.networks}.#
#' @param SpeciesInfo A dataframe of x and y coordinates and associated species information. Should only include plots that have the species of interest.#
#' @param start.seed The initial number used in \code{set.seed}. All subsequent numbers used in set.seed will be incremental after this number. seed = seq(start.seed, start.seed + 2*n.realizations +  sum(n.networks)*n.realizations*2 + 1, by=1)#
#' @param variables Dataframe column names that are included in the final patch realizations. These columsn are given a value of "0" if the species is not present or NA.#
#' @description This function creates multiple realizations of patches of the species of interest within the grid of locations created with \code{createPopulation}.#
#' @references Sauby, K.E and Christman, M.C. \emph{In preparation.} Restricted adaptive cluster sampling.#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' library(ggplot2)#
#' # EXAMPLE 1#
#' # how large does the buffer need to be when generating realizations? (so #
#' #	that network units are not truncated by the dimensions of the realization #
#' #	grid)#
#' data(PlotSurveys_season1)#
#' PlotSurveys_season1 %>%#
#'	as.data.frame %>%#
#' 	summarise(#
#' 		max_x_buffer = max(abs(Rel_x)),#
#' 		max_y_buffer = max(abs(Rel_y))#
#' 	)#
#' #
#' # realization info#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' n.networks = c(5, 15, 10, 20, 30, 40)#
#' n.realizations = 1#
#' SpeciesInfo = PlotSurveys_season1#
#' variables = c("Stricta", "Pusilla", "Cactus")#
#' start.seed=1#
#' buffer=5#
#' #
#' # create realizations#
#' CactusRealizations = createSpeciesPatchRealizations(x_start, x_end, #
#' 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, start.seed,#
#' 	variables)#
#' #
#' # plot realizations#
#' p <- ggplot(CactusRealizations, aes(x, y, colour=NetworkID, #
#'		label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(CactusRealizations %>% filter(m>1), aes(x, y, colour=NetworkID,#
#'	 	label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(Cactus))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' # EXAMPLE 2#
#' #
#' # realization info	#
#' x_start = 1#
#' x_end = 20#
#' y_start = 1#
#' y_end = 20#
#' n.networks = c(1,2,3)#
#' n.realizations = 1#
#' SpeciesInfo = Thompson1990Fig1Pop %>% #
#' 	filter(m > 1) %>% #
#' 	createNetworks#
#' variables = "y_value"#
#' buffer=5#
#' start.seed=1#
#' #
#' # create realizations#
#' Thompson.realizations = createRealizations(x_start, x_end,#
#'	 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, #
#'		start.seed, variables)	#
#' #
#' # plot realizations#
#' p <- ggplot(Thompson.realizations, aes(x, y, colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end, #
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#'#
#' p <- ggplot(Thompson.realizations %>% filter(m > 1), aes(x, y, #
#'		colour=NetworkID, label=NetworkID))#
#' p + annotate("rect", xmin=x_start, xmax=x_end, ymin=y_start, ymax=y_end,#
#'		alpha=0, colour="grey") + #
#' 	geom_point(aes(size=factor(y_value))) + #
#' 	facet_wrap(~n.networks) + #
#' 	scale_colour_gradientn(colours = rainbow(7)) +#
#' 	geom_text(aes(label=NetworkID), hjust=0, vjust=0)#
#' @export#
#
createRealizations <- function(#
	x_start, #
	x_end, #
	y_start, #
	y_end, #
	buffer, #
	n.networks, #
	n.realizations, #
	SpeciesInfo, #
	start.seed, #
	variables#
)#
{#
	x <- y <- Rel_x <- Rel_y <- NetworkID <- m <- NULL#
	network.length = length(n.networks)#
	seed = seq(start.seed, start.seed + 2*n.realizations + #
		sum(n.networks)*n.realizations*2 + 1, by=1)#
    grid <- createPop(#
		x_start + buffer, #
		x_end - buffer, #
		y_start + buffer, #
		y_end - buffer#
	)#
	patch.array <- vector("list", network.length)#
	for (i in 1:length(n.networks)) { 	#
		patch.array[[i]] <- list()#
		for (j in 1:n.realizations) { 			#
			patch = createSpeciesPatch(#
				grid, #
				n.networks[i], #
				seed, #
				cluster.info=SpeciesInfo, #
				x=x, #
				y=y, #
				Rel_x=Rel_x, #
				Rel_y=Rel_y#
			)	#
			# fill in absence data#
			population = createPop(#
				x_start, #
				x_end, #
				y_start, #
				y_end#
			)#
			patch %<>% merge(population, by=c("x", "y"), all=T)#
			for (k in 1:length(variables)) {#
				patch[which(is.na(patch[,variables[k]])), #
					variables[k]] <- 0#
			}#
			patch[which(is.na(patch$NetworkID)), ]$NetworkID <- seq(#
				max(patch$NetworkID, na.rm=T) + 1,#
				length(patch[which(is.na(patch$NetworkID)), ]$NetworkID) + #
					max(patch$NetworkID, na.rm=T), #
				by=1#
			) #
			# other info#
			patch.array[[i]][[j]] <- patch#
			patch.array[[i]][[j]]$n.networks <- n.networks[i]#
			patch.array[[i]][[j]]$realization <- j#
			# fill in missing m values#
			patch.array[[i]][[j]] %<>% #
				group_by(NetworkID) %>% #
				mutate(m = length(m))#
		}#
		max.seed = max(patch$rotation.seed, na.rm=T)#
		if (is.na(n.networks[i+1])) {seed = NA} else {#
			seed = seq(max.seed, max.seed + 2*n.realizations + #
				sum(n.networks)*n.realizations*2 + 1, by=1)#
		}#
	}	#
	# compress list of patch data to dataframe#
	patch_data = do.call(rbind.fill, unlist(patch.array, recursive=F))#
	patch_data$N = dim(population)[1]#
	return(patch_data)#
}
CactusRealizations <- createCactusRealizations(#
 	PlotSurveys_season1, #
 	ovar = c(#
 	"Stricta",#
 	"Pusilla",#
 	"Cactus",#
 	"CACA_on_Pusilla",	"CACA_on_Stricta",#
 	"MEPR_on_Pusilla",#
 	"MEPR_on_Stricta",#
 	"Old_Moth_Evidence_Pusilla",#
 	"Old_Moth_Evidence_Stricta"#
 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
 	# "Percent_Cover_Stricta",#
# "Height_Pusilla",#
#' 	# "Height_Stricta",#
 )		#
 )
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
CactusRealizationSummary <- calculatePopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Calculate SSQ_R#
#' #
#' @description SSQ_R is the ratio of the within-network sum of squares to the total sum of squares. ACS design becomes more efficient relative to simple random sampling as the within-network variation increases relative to the overall variation [@thompson1996adaptive]. We calculate \deqn{SSQ_R = SSQ_w/SSQ_\tau}{SSQ_R = SSQ_w/SSQ_tau} as the ratio of the within-network sum of squares \deqn{SSQ_w = \sum_{j=1}^{\kappa} \sum_{i \in j} (y_{j,i} - \bar{y_{j}})^2}{SSQ_w = \sum_{j=1}^{\kappa} \sum_{i \in j} (y_{j,i} - \bar{y_{j}})^2}, to the total sum of squares \deqn{SSQ_\tau= \sum_{i=1}^{N} (y_i - \mu)^2}{SSQ_\tau= \sum_{i=1}^{N} (y_i - \mu)^2}. Thus, an increase in \code{SSQ_R} indicates an increase in the efficiency of the ACS design relative to SRSWOR.#
#' @param popdata Information about the populations of interest.#
#' @param popgroupvar A variable identifying the separate populations. If only one population in popdata, set popgroupvar = NULL.#
#' @param variable Variable for which to calculate SSQr.#
#' @return Dataframe including original data and RE estimates.#
#' @export#
#' @references su2003estimator#
#' @examples#
#' data(Thompson1990Figure1Population)#
#' temp <- Thompson1990Figure1Population %>%#
#' 	mutate(pop = 1)#
#' popdata <- temp#
#' variable <- "y_value"#
#' popgroupvar <- "pop"#
#' calcSSQR(popdata, variable, popgroupvar)#
#' popgroupvar <- NA#
#' calcSSQR(popdata, variable, popgroupvar)#
calcSSQR <- function(popdata, variable, popgroupvar=NA) {#
	VAR <- sym(variable)#
	if (!(is.na(popgroupvar))) {#
		POPVAR <- sym(popgroupvar)#
	}#
	if (is.na(popgroupvar)) {#
		network_mean <- popdata %>%#
			group_by(NetworkID) %>%#
			summarise(#
				network_mean = mean(!!VAR, na.rm = TRUE)#
			)#
		overall_mean <- popdata %>%#
			summarise(#
				overall_mean = mean(!!VAR, na.rm = TRUE)#
			)#
		popdata %>% merge(#
			network_mean, #
			by="NetworkID"#
		) %>%#
			merge(overall_mean) %>%#
			mutate(#
				SSQw_j = (!!VAR - .data$network_mean)^2,#
				SSQt_i = (!!VAR - .data$overall_mean)^2#
			) %>%#
			group_by(!!POPVAR) %>%#
			summarise(#
				SSQw = sum(.data$SSQw_j),#
				SSQt = sum(.data$SSQt_i)#
			) %>%#
			mutate(#
				SSQ_R = .data$SSQw / .data$SSQt#
			) %>%#
			dplyr::select(-c(.data$SSQw, .data$SSQt))#
	} else {#
		network_mean <- popdata %>%#
			group_by(NetworkID, !!POPVAR) %>%#
			summarise(#
				network_mean = mean(!!VAR, na.rm = TRUE)#
			)#
		overall_mean <- popdata %>%#
			group_by(!!POPVAR) %>%#
			summarise(#
				overall_mean = mean(!!VAR, na.rm = TRUE)#
			)#
		popdata %>% merge(#
			network_mean, #
			by=c(popgroupvar, "NetworkID")#
		) %>%#
			merge(overall_mean, by = popgroupvar) %>%#
			mutate(#
				SSQw_j = (!!VAR - network_mean)^2,#
				SSQt_i = (!!VAR - overall_mean)^2#
			) %>%#
			group_by(!!POPVAR) %>%#
			summarise(#
				SSQw = sum(.data$SSQw_j),#
				SSQt = sum(.data$SSQt_i)#
			) %>%#
			mutate(#
				SSQ_R = .data$SSQw / .data$SSQt,#
				variable_name = variable#
			) %>%#
			dplyr::select(-c(.data$SSQw, .data$SSQt, .data$variable_name))#
	}#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
CactusRealizationSummary <- calculatePopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Return the sum of a vector, after removing NAs.#
#' #
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
Sum <- function(x) {sum(x, na.rm=TRUE)}#
#
#' Return the mean of a vector with up to two decimal places, after removing NAs.#
#' #
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
Mean <- function(x) base::mean(x, na.rm=TRUE)#
#' Return the population variance of a vector, after removing NAs, and round.#
#'#
#' @param x Vectors of data.#
#' @description Written for use in the tables::tabular function to create publication-ready tables.#
#
PopVariance <- function(x) {#
	temp <- sum((x-mean(x))^2)/length(x)#
}#
#
#' Population Coefficient of Variation#
#' #
#' @param x Vectors of data.#
#
popCV <- function(x) {sqrt(PopVariance(x))/Mean(x)}#
#
#' Calculate Summary Statistics for Patch Population Data#
#' #
#' @param population_data Data on multiple realizations of patches of the species of interest within the grid of locations (created by \code{createSpeciesPatchPopulations} function).#
#' @param summaryvar Vector of variables for which summary statistics should be calculated.#
#' @param popgroupvar String identifying the categorical variable identifying the different populations.#
#' @param rvar Vector of variables for which ratio estimators should be used.#
#' @param spatweights Vector of spatial weight matrix styles. Can take on values "W", "B", "C", "U", "S", and "minmax". See nb2listw for more details.#
#
#' @description Calculates summary statistics for patch population data.#
#
#' @return Dataframe including summary statistics for each column identified in \code{summaryvar} and for each category identified in \code{popgroupvar}.#
#
#' @export#
#' @importFrom dplyr ungroup sym group_by_at#
#' @importFrom stringr str_sub#
#' @importFrom stats var#
#' @importFrom sp coordinates#
#' @importFrom spdep cell2nb nb2listw joincount.test moran.test #
#
#' @examples#
#' library(magrittr)#
#' library(dplyr)#
#' ovar = c(#
#' 	"Stricta",#
#' 	"Pusilla",#
#' 	"Cactus",#
#' 	"CACA_on_Pusilla",#
#' 	"CACA_on_Stricta",#
#' 	"MEPR_on_Pusilla",#
#' 	"MEPR_on_Stricta",#
#' 	"Old_Moth_Evidence_Pusilla",#
#' 	"Old_Moth_Evidence_Stricta"#
#' 	# "Percent_Cover_Pusilla", # how do I do these? they are occupancy nor abundance#
#' 	# "Percent_Cover_Stricta",#
#' 	# "Height_Pusilla",#
#' 	# "Height_Stricta",#
#' )		#
#' summaryvar = ovar#
#' # WHAT WAS I THINK HERE? for grouping variables?#
#' popgroupvar = "n.networks" # c("n.networks", "realization")#
#' # create realizations#
#' x_start = 1#
#' x_end = 30#
#' y_start = 1#
#' y_end = 30#
#' n.networks = c(5, 15, 10, 20, 30, 40)#
#' n.realizations = 1#
#' SpeciesInfo = PlotSurveys_season1#
#' start.seed=1#
#' buffer=5#
#' rvar = c("CACA_on_Stricta", "CACA_on_Pusilla")#
#' cactus.realizations <- createSpeciesPatchRealizations(x_start, x_end,#
#' 	y_start, y_end, buffer, n.networks, n.realizations, SpeciesInfo, start.seed,#
#' 	ovar)#
#' patch_data_summary <- calculatePopulationSummaryStatistics(cactus.realizations, #
#' 	summaryvar=ovar, popgroupvar=popgroupvar, nrow=30, ncol=30)#
calcPopSummaryStats <- function(#
	popdata, #
	summaryvar, #
	rvar=NULL, #
	popgroupvar,#
	spatweights="S",#
	nrow,#
	ncol#
) {#
	POPVAR <- sym(popgroupvar)#
	popdata %<>% arrange(!!POPVAR)#
	# for each popgroupvar combo, calculate summary statistics for m and number of species patches#
	# this calculates the m statistics for the unique Network sizes#
	Y1 <- popdata %>%#
		group_by_at(c("NetworkID", popgroupvar)) %>%#
		summarise(m = .data$m[1]) %>%#
		group_by_at(popgroupvar) %>%#
		summarise(#
			m_min_unique_neigh = min(.data$m),#
			m_max_unique_neigh = max(.data$m),#
			m_mean_unique_neigh = mean(.data$m),#
			m_var_unique_neigh = var(.data$m),#
			n_Species_Patches = #
				length(unique(.data$NetworkID[which(.data$m>1)]))#
		) %>%#
		ungroup %>%#
		as.data.frame#
	# this calculates the m statistics for all units#
	Y2 = popdata %>%#
	group_by_at(popgroupvar) %>%#
		summarise(#
			m_min = min(.data$m),#
			m_max = max(.data$m),#
			m_mean = mean(.data$m),#
			m_var = var(.data$m)#
		) %>%#
		ungroup %>%#
		as.data.frame#
	Z = popdata %>%#
		group_by_at(popgroupvar) %>%#
		summarise(N = length(.data$m)) %>%#
		ungroup %>%#
		as.data.frame#
	Y1 %<>% #
		merge(Y2, by=popgroupvar) %>%#
		merge(Z, by=popgroupvar)	#
	# spatial statistics and other characteristics of variables#
	A <- list()#
	popvar <- paste(#
		"popdata$", #
		popgroupvar, #
		sep=""#
	)#
	for (i in 1:length(unique(eval(parse(text=popvar))))) {#
		temp <- popdata %>%#
			filter(!!POPVAR == unique(!!POPVAR)[i])#
		temp %<>% arrange(.data$x,.data$y)#
		# spatial statistics#
		coordinates(temp) = ~ x + y#
		A[[i]] <- list()#
		for (j in 1:length(summaryvar)) {#
			A[[i]][[j]] <- data.frame(variable = summaryvar[j])#
			if (summaryvar[j] %in% rvar) {#
				temp_ratio <- temp %>% as.data.frame#
				temp_ratio %<>% #
					.[.[colnames(.)==str_sub(summaryvar[j],-7,-1)]==1, ]	#
				tempvar <- eval(parse(text =#
						paste("temp_ratio$", summaryvar[j], sep="")#
					))#
				coordinates(temp_ratio) = ~ x + y#
			} else {#
				tempvar <- eval(parse(text =#
					paste("temp$", summaryvar[j], sep="")#
				))	#
			}#
			A[[i]][[j]]$Mean_tempvar 	<- Mean(tempvar)#
			A[[i]][[j]]$Var_tempvar 	<- PopVariance(tempvar)#
			A[[i]][[j]]$CV_tempvar 		<- popCV(tempvar)#
			A[[i]][[j]]$Total_tempvar 	<- Sum(tempvar)#
			A[[i]][[j]]$SSQ_R			<- calcSSQR(#
				popdata = as.data.frame(temp),#
				variable = summaryvar[j],#
				popgroupvar#
			)$SSQ_R#
			# for join counts and moran's i, change NAs in rvar's to zeros#
			temp2 <- temp#
			temp2@data[rvar][is.na(temp2@data[rvar])] <- 0#
			if (length(tempvar[which(tempvar > 0)]) > 0) {#
				# join counts and moran's i#
				nb <- cell2nb(nrow = nrow, ncol = ncol)#
				if ("W" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "W") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.W <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.W <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}#
				if ("B" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "B") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.B <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.B <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("C" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "C") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.C <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.C <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("U" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "U") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.U <- joincount.test(as.factor(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.U <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("S" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "S") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.S <- joincount.test(as.factor(#
						# NEED TO FIGURE OUT HOW TO GET RID OF NAs#
						# OR CAN YOU JUST NOT DO JOINT COUNT TEST FOR RVAR#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.S <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
				if ("minmax" %in% spatweights) {#
					lwb <- nb2listw(nb, style = "minmax") # convert to spatweights#
					# I think cells are indexed by row, then column#
					A[[i]][[j]]$JoinCountTest.minmax <- joincount.test(#
						as.factor(eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						)))),#
						lwb#
					)[[2]]$estimate[1]#
					A[[i]][[j]]$MoranI.minmax <- moran.test(#
						eval(parse(text=paste(#
							"temp2$",#
							summaryvar[j],#
							sep=""#
						))),#
						lwb#
					)$estimate[1]#
				}	#
			} else {#
				if ("W" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.W <- NA#
					A[[i]][[j]]$MoranI.W <- NA#
				}#
				if ("B" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.B <- NA#
					A[[i]][[j]]$MoranI.B <- NA#
				}	#
				if ("C" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.C <- NA#
					A[[i]][[j]]$MoranI.C <- NA#
				}	#
				if ("U" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.U <- NA#
					A[[i]][[j]]$MoranI.U <- NA#
				}	#
				if ("S" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.S <- NA#
					A[[i]][[j]]$MoranI.S <- NA#
				}	#
				if ("minmax" %in% spatweights) {#
					A[[i]][[j]]$JoinCountTest.minmax <- NA#
					A[[i]][[j]]$MoranI.minmax <- NA#
				}	#
			}#
		}#
		A[[i]] <- do.call(rbind.data.frame, A[[i]])#
		A[[i]]$population <- unique(eval(parse(#
			text=paste(#
				"popdata$", #
				popgroupvar, #
				sep=""#
			)#
		)))[i]#
	}#
	B <- do.call(rbind.data.frame, A)#
	B %<>% arrange(variable, population) %>%#
		dplyr::rename(#
			Mean = Mean_tempvar,#
			Var = Var_tempvar,#
			CV = CV_tempvar,#
			Total = Total_tempvar#
		)#
	return(list(Y1, B))#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)
}
}
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)
)
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)
?save
saveRDS(CactusRealizations, file="CactusRealizations.rda")
getwd()
setwd('/Users/KSauby/Documents/Projects/ACS/R')
Thompson1990Fig1Pop <- createThompson1990Fig1Pop()
saveRDS(Thompson1990Fig1Pop, file="Thompson1990Fig1Pop.rda")
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 6, SamplingDesign=ACS, N.SRSWOR.plots==100", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_6 <- patch_data_summary_wide %>% filter(population==6)#
	# WHERE DOES SIMULATION DATA COME FROM#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_6$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RB_Stricta <- 100 * (#
		mean(temp_sim_data$Stricta_mean_observed) - population_6$Stricta_mean#
	) / population_6$Stricta_mean#
	RE_Stricta <- (#
		population_6$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_6$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RB_CACA_on_Stricta <- 100 * (#
		mean(temp_sim_data$CACA_on_Stricta_ratio_mean_observed) - #
		population_6$CACA_on_Stricta_ratio_mean#
	) / population_6$CACA_on_Stricta_ratio_mean#
	RB_MEPR_on_Stricta <- 100 * (#
		mean(temp_sim_data$MEPR_on_Stricta_ratio_mean_observed) - #
		population_6$MEPR_on_Stricta_ratio_mean#
	) / population_6$MEPR_on_Stricta_ratio_mean#
	RB_Old_Moth_Evidence_Stricta <- 100 * (#
		mean(temp_sim_data$Old_Moth_Evidence_Stricta_ratio_mean_observed) - #
		population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	) / population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	RE_CACA_on_Stricta <- (#
		population_6$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta <- (#
		population_6$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta <- (#
		population_6$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias <- calculateSamplingBias(#
		population_data_summary	= population_6, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_6,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#	 	RB#
	expect_equal(#
		RB_Stricta,#
		example_bias$Stricta_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RB#
	expect_equal(#
		RB_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 1, SamplingDesign=ACS, N.SRSWOR.plots==40", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_1 <- patch_data_summary_wide %>% filter(population==1)#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==1, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==40#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==1, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==40,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_1$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RE_Stricta = (#
		population_1$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_1$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RE_CACA_on_Stricta = (#
		population_1$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta = (#
		population_1$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta = (#
		population_1$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias = calculateSamplingBias(#
		population_data_summary	= population_1, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_1,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})#
test_that("Sampling Bias and Relative Efficiency, population 1, SamplingDesign=RACS with new_y_HT formula, N.SRSWOR.plots==40", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		PopulationSummaryStatistics = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_1 <- patch_data_summary_wide %>% filter(population==1)#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simdata_new_yHT_re %>% filter(#
		population==1, #
		SamplingDesign=="RACS", #
		N.SRSWOR.plots==40#
	)#
	temp_sim_data_ratio <- simdata_new_yHT_re %>% filter(#
		population==1, #
		SamplingDesign=="RACS", #
		N.SRSWOR.plots==40,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_1$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RE_Stricta = (#
		population_1$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_1$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_1$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RE_CACA_on_Stricta = (#
		population_1$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta = (#
		population_1$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta = (#
		population_1$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_1$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias = calculateSamplingBias(#
		population_data_summary	= population_1, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_1,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("calculatePopulationSummaryStatistics", {#
	CactusRealizationSummary <- calcPopSummaryStats(#
		popdata = CactusRealizations, #
		summaryvar = c("Stricta", "Pusilla", "Cactus",#
			"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
		popgroupvar = "population", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
			"Percent_Cover_Stricta", "Height_Stricta", #
			"Old_Moth_Evidence_Stricta"),#
		nrow=30,#
		ncol=30#
	)#
	# TEST RATIO VARIABLE CALCULATIONS#
	# population 1#
	pop_1_stricta <- CactusRealizations %>% filter(population==1, Stricta==1)#
	mean_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	CV_pop_1_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="CACA_on_Stricta") %$% #
		CV#
	CV_pop_1_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="MEPR_on_Stricta") %$% #
		CV#
	CV_pop_1_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==1, variable=="Old_Moth_Evidence_Stricta") %$% #
		CV#
	expect_equal(#
		mean_pop_1_CACA_on_Stricta,#
		mean(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_MEPR_on_Stricta,#
		mean(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_1_Old_Moth_Evidence_Stricta,#
		mean(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_1_CACA_on_Stricta,#
		PopVariance(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_MEPR_on_Stricta,#
		PopVariance(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_1_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_CACA_on_Stricta,#
		popCV(pop_1_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_MEPR_on_Stricta,#
		popCV(pop_1_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		CV_pop_1_Old_Moth_Evidence_Stricta,#
		popCV(pop_1_stricta$Old_Moth_Evidence_Stricta)#
	)#
	# population 6#
	pop_6_stricta <- CactusRealizations %>% filter(population==6, Stricta==1)#
	mean_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Mean#
	mean_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Mean#
	mean_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Mean#
	var_pop_6_CACA_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="CACA_on_Stricta") %$% #
		Var#
	var_pop_6_MEPR_on_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="MEPR_on_Stricta") %$% #
		Var#
	var_pop_6_Old_Moth_Evidence_Stricta <- CactusRealizationSummary[[2]] %>% #
		filter(population==6, variable=="Old_Moth_Evidence_Stricta") %$% #
		Var#
	expect_equal(#
		mean_pop_6_CACA_on_Stricta,#
		mean(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_MEPR_on_Stricta,#
		mean(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		mean_pop_6_Old_Moth_Evidence_Stricta,#
		mean(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
	expect_equal(#
		var_pop_6_CACA_on_Stricta,#
		PopVariance(pop_6_stricta$CACA_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_MEPR_on_Stricta,#
		PopVariance(pop_6_stricta$MEPR_on_Stricta)#
	)#
	expect_equal(#
		var_pop_6_Old_Moth_Evidence_Stricta,#
		PopVariance(pop_6_stricta$Old_Moth_Evidence_Stricta)#
	)#
})
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("Sampling Bias and Relative Efficiency, population 6, SamplingDesign=ACS, N.SRSWOR.plots==100", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_6 <- patch_data_summary_wide %>% filter(population==6)#
	# WHERE DOES SIMULATION DATA COME FROM#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_6$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RB_Stricta <- 100 * (#
		mean(temp_sim_data$Stricta_mean_observed) - population_6$Stricta_mean#
	) / population_6$Stricta_mean#
	RE_Stricta <- (#
		population_6$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_6$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RB_CACA_on_Stricta <- 100 * (#
		mean(temp_sim_data$CACA_on_Stricta_ratio_mean_observed) - #
		population_6$CACA_on_Stricta_ratio_mean#
	) / population_6$CACA_on_Stricta_ratio_mean#
	RB_MEPR_on_Stricta <- 100 * (#
		mean(temp_sim_data$MEPR_on_Stricta_ratio_mean_observed) - #
		population_6$MEPR_on_Stricta_ratio_mean#
	) / population_6$MEPR_on_Stricta_ratio_mean#
	RB_Old_Moth_Evidence_Stricta <- 100 * (#
		mean(temp_sim_data$Old_Moth_Evidence_Stricta_ratio_mean_observed) - #
		population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	) / population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	RE_CACA_on_Stricta <- (#
		population_6$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta <- (#
		population_6$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta <- (#
		population_6$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias <- calculateSamplingBias(#
		population_data_summary	= population_6, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_6,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#	 	RB#
	expect_equal(#
		RB_Stricta,#
		example_bias$Stricta_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RB#
	expect_equal(#
		RB_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})
??spread
library(tidyr)
setwd('/Users/KSauby/Documents/Projects/ACS/R')
#' Create "Wide" Format Population Summary Statistics for Population Data#
#' #
#' @param popsummarystats Created by the function calculatePopSummaryStats.#
#' @param ovar vector of occupancy variables#
#' @param rvar vector of ratio variables#
#' @return Dataframe with a column per mean/variance of each variable and a row per population.#
#' @export#
#' @importFrom tidyr spread#
#' @examples#
#' CactusRealizationSummary <- calculatePopSummaryStats(#
#' 	popdata = CactusRealizations, #
#' 	summaryvar = c("Stricta", "Pusilla", "Cactus",#
#' 		"MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
#' 		"Height_Stricta", "Old_Moth_Evidence_Stricta"), #
#' 	popgroupvar = "population", #
#' 	rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", #
#' 		"Percent_Cover_Stricta", "Height_Stricta", #
#' 		"Old_Moth_Evidence_Stricta"),#
#' 	nrow=30,#
#' 	ncol=30#
#' )#
#' patch_data_summary_wide <- createWidePopSummaryStats(#
#' 	popsummarystats = CactusRealizationSummary,#
#' 	ovar = "Stricta",#
#' 	rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
#' 		"Height_Stricta", "Old_Moth_Evidence_Stricta")#
#' )#
createWidePopSummaryStats <- function(popsummarystats, ovar, rvar) {#
	# variance#
	popsummarystats[[2]]$variable %<>% as.character()#
	A <- popsummarystats[[2]] %>%#
		select(.data$Var, .data$variable, .data$population) %>%#
		mutate(#
			variable = ifelse(#
				.data$variable %in% rvar,#
				paste(.data$variable, "ratio", sep="_"),#
				.data$variable#
			)#
		) %>%#
		spread(key=variable, value=Var)#
	nvar <- length(unique(popsummarystats[[2]]$variable))#
	names(A)[2:(nvar + 1)] <- paste(names(A)[2:(nvar + 1)], "var", sep="_")#
	# mean#
	B <- popsummarystats[[2]] %>%#
		select(.data$Mean, .data$variable, .data$population) %>%#
		mutate(#
			variable = ifelse(#
				.data$variable %in% rvar,#
				paste(.data$variable, "ratio", sep="_"),#
				.data$variable#
			)#
		) %>%#
		spread(key=variable, value=Mean)#
	names(B)[2:(nvar + 1)] <- paste(names(B)[2:(nvar + 1)], "mean", sep="_")#
	# population size#
	C <- popsummarystats[[1]] %>%#
		select(.data$population, .data$N)#
	# merge all together#
	merge(A, B, by="population") %>% merge(C, by="population")#
}
setwd('/Users/KSauby/Documents/Projects/ACS/tests/testthat')
test_that("Sampling Bias and Relative Efficiency, population 6, SamplingDesign=ACS, N.SRSWOR.plots==100", {	#
	patch_data_summary_wide <- createWidePopSummaryStats(#
		popsummarystats = CactusRealizationSummary,#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	population_6 <- patch_data_summary_wide %>% filter(population==6)#
	# WHERE DOES SIMULATION DATA COME FROM#
	# MANUALLY CALCULATE MSE and RE#
	temp_sim_data <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100#
	)#
	temp_sim_data_ratio <- simulation_data %>% filter(#
		population==6, #
		SamplingDesign=="ACS", #
		N.SRSWOR.plots==100,#
		Stricta_mean_observed > 0#
	)#
	# occupancy variables#
	mean_MSE_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data$Stricta_mean_observed - #
			# true#
			population_6$Stricta_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data)[1]#
	RB_Stricta <- 100 * (#
		mean(temp_sim_data$Stricta_mean_observed) - population_6$Stricta_mean#
	) / population_6$Stricta_mean#
	RE_Stricta <- (#
		population_6$Stricta_var/unique(temp_sim_data$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Stricta#
	# ratio variables#
	mean_MSE_CACA_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$CACA_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$CACA_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_MEPR_on_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$MEPR_on_Stricta_ratio_mean_observed - #
			# true#
			population_6$MEPR_on_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	mean_MSE_Old_Moth_Evidence_Stricta <- sum(#
		(#
			# observed#
			temp_sim_data_ratio$Old_Moth_Evidence_Stricta_ratio_mean_observed - #
			# true#
			population_6$Old_Moth_Evidence_Stricta_ratio_mean#
		)^2#
	# n simulations#
	)/dim(temp_sim_data_ratio)[1]#
	RB_CACA_on_Stricta <- 100 * (#
		mean(temp_sim_data$CACA_on_Stricta_ratio_mean_observed) - #
		population_6$CACA_on_Stricta_ratio_mean#
	) / population_6$CACA_on_Stricta_ratio_mean#
	RB_MEPR_on_Stricta <- 100 * (#
		mean(temp_sim_data$MEPR_on_Stricta_ratio_mean_observed) - #
		population_6$MEPR_on_Stricta_ratio_mean#
	) / population_6$MEPR_on_Stricta_ratio_mean#
	RB_Old_Moth_Evidence_Stricta <- 100 * (#
		mean(temp_sim_data$Old_Moth_Evidence_Stricta_ratio_mean_observed) - #
		population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	) / population_6$Old_Moth_Evidence_Stricta_ratio_mean#
	RE_CACA_on_Stricta <- (#
		population_6$CACA_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_CACA_on_Stricta#
	RE_MEPR_on_Stricta <- (#
		population_6$MEPR_on_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_MEPR_on_Stricta#
	RE_Old_Moth_Evidence_Stricta <- (#
		population_6$Old_Moth_Evidence_Stricta_ratio_var/unique(temp_sim_data_ratio$N.Total.plots_mean) *#
		(1 - unique(temp_sim_data_ratio$N.Total.plots_mean)/population_6$N)#
	) /	mean_MSE_Old_Moth_Evidence_Stricta#
	# CALCULATE MSE and RE USING FUNCTIONS#
	example_bias <- calculateSamplingBias(#
		population_data_summary	= population_6, #
		simulation_data = temp_sim_data, #
		sampling.grouping.variables	= c("N.Total.plots_mean", "N.SRSWOR.plots", #
			"SamplingDesign"), #
		population.grouping.variables = "population",#
		ovar = "Stricta", #
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	RE_values <- calculateRE(#
		population_data = population_6,#
		MSE_ComparisonSamplingDesign = example_bias,#
		population.grouping.variables = "population",#
		sample.size.variable = "N.Total.plots_mean",#
		ovar = "Stricta",#
		rvar = c("MEPR_on_Stricta", "CACA_on_Stricta", "Percent_Cover_Stricta", #
			"Height_Stricta", "Old_Moth_Evidence_Stricta")#
	)#
	# TEST FUNCTION CALCULATIONS	#
	# 	occupancy variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_Stricta,#
		example_bias$Stricta_mean_MSE#
	)#
	#	 	RB#
	expect_equal(#
		RB_Stricta,#
		example_bias$Stricta_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_Stricta,#
		RE_values$Stricta_RE#
	)#
	# 	ratio variables#
	# 		MSE#
	expect_equal(#
		mean_MSE_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_MSE#
	)#
	expect_equal(#
		mean_MSE_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_MSE#
	)#
	#		RB#
	expect_equal(#
		RB_CACA_on_Stricta,#
		example_bias$CACA_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_MEPR_on_Stricta,#
		example_bias$MEPR_on_Stricta_ratio_mean_RB#
	)#
	expect_equal(#
		RB_Old_Moth_Evidence_Stricta,#
		example_bias$Old_Moth_Evidence_Stricta_ratio_mean_RB#
	)#
	#		RE#
	expect_equal(#
		RE_CACA_on_Stricta,#
		RE_values$CACA_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_MEPR_on_Stricta,#
		RE_values$MEPR_on_Stricta_ratio_RE#
	)#
	expect_equal(#
		RE_Old_Moth_Evidence_Stricta,#
		RE_values$Old_Moth_Evidence_Stricta_ratio_RE#
	)#
})
